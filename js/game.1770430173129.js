/* Lablix 1770430173129 */

// ========== taunts.json (auto-embedded) ==========
const TAUNTS_DATA = {
    "edge_proximity": {
        "en": [
            "You're one twitch away from total failure, you absolute clown!",
            "Teetering like the useless lump you areâ€”FALL ALREADY!",
            "So close to the edge... just like your grip on competence!",
            "I can practically hear your pathetic little heart racing!",
            "The void is begging for you, you trembling waste of space!",
            "Sweaty palms yet? That's the taste of inevitable defeat!",
            "Come on, lean inâ€”just a little more, you hopeless disaster!",
            "Edge of glory? More like edge of your worthless existence!",
            "One. Tiny. Slip. And you're gone forever. DO IT!",
            "Watching you wobble is the only joy I get from your garbage play!",
            "PLUMMET ALREADY, YOU SPINELESS WORM!",
            "The abyss is hungry, and you're the perfect snackâ€”FAIL!"
        ],
        "it": [
            "Sei un fallimento totale. Pagliaccio!",
            "Barcolli come il nulla che sei. CADI CHE RISPARMIAMO TEMPO!",
            "Un altro millimetro e finisci nel dimenticatoio, fenomeno da baraccone!",
            "CosÃ¬ vicino al bordo... una metafora sulla tua vita!",
            "Sento quasi il tuo patetico cuoricino accelerare!",
            "Il vuoto ti sta chiamando per nome, rispondigli, codardo!",
            "Il vuoto ti implora, sei uno spreco di ossigeno!",
            "Dai, sporgiti un po' di piÃ¹, tanto sei giÃ  un fallito!",
            "Palmi sudati? Ãˆ il sapore della sconfitta inevitabile!",
            "Dai, sporgiti, solo un altro po', cane senza appello!",
            "Un piccolo scivolone e addio al peggior giocatore del pianeta!",
            "Sull'orlo della gloria? PiÃ¹ sull'orlo della tua fine senza senso!",
            "Ti vedo barcollare come la tua autostima: zero equilibrio!",
            "Un passetto e sparisci per sempre. Fatti questo favore!",
            "Guardarti barcollare Ã¨ l'unica gioia dal tuo gioco schifoso!",
            "Precipita! Verme senza spina dorsale!",
            "L'abisso ha fame e tu sei lo spuntino perfetto.!"
        ]
    },
    "after_hit": {
        "en": [
            "Direct hit, you sluggish sack of failure!",
            "HAHA! Took that right to the face, didn't you, loser?",
            "What, you thought standing still was a strategy? Idiot!",
            "That had to stingâ€”your ego more than anything!",
            "Dodge? You? Don't make me laugh, you stationary target!",
            "Too slow, too stupid, too utterly pathetic!",
            "Those reflexes belong in a museum of failure!",
            "Bullseye on the world's worst playerâ€”congrats, trash!",
            "You're not even trying to hide how bad you are!",
            "I've hit stationary objects that moved better than you!",
            "Lag? No, that's just your complete lack of skill!",
            "ABSOLUTE DISGRACEâ€”how are you this useless?!"
        ],
        "it": [
            "Colpo diretto, sacco flaccido di fallimento!",
            "Ahi, quello ha fatto male... alla tua dignitÃ , soprattutto!",
            "Sei piÃ¹ lento di un bradipo morto!",
            "HAHA! Te lo sei preso dritto in faccia, vero, perdente?",
            "Questo avrÃ  fatto piÃ¹ male al tuo ego che ad altro!",
            "Ho visto statue piÃ¹ mobili di te!",
            "Centro perfetto sul re dei perdenti, che onore per me!",
            "Troppo lento, troppo stupido, totalmente patetico!",
            "I tuoi riflessi meritano un museo del fallimento!",
            "Centro perfetto sul peggior giocatore del mondo, complimenti... spazzatura!",
            "Non stai neanche provando a nascondere quanto fai schifo!",
            "Come fai a essere cosÃ¬ inutile?!"
        ]
    },
    "reckless_movement": {
        "en": [
            "Whoa, calm down, you reckless imbecileâ€”death is coming!",
            "Slow down before you embarrass yourself any further!",
            "Look at you goâ€”straight into utter humiliation!",
            "Overconfident trash thinking speed beats skill!",
            "Physics hates you almost as much as I do!",
            "Keep flailing like that, idiotâ€”it's hilarious!",
            "Fast, furious, and about to be completely destroyed!",
            "Your momentum? Just speeding you toward total failure!"
        ],
        "it": [
            "Ehi, calmati, la morte sta arrivando!",
            "Spericolato? PiÃ¹ che altro suicida con zero stile!",
            "Corri come se avessi un cervello... ah no, scusa, non ce l'hai!",
            "Vai forte, eh? Peccato che la competenza non tenga il passo!",
            "Rallenta prima di imbarazzarti ancora di piÃ¹!",
            "Guarda come vai dritto verso l'umiliazione totale!",
            "Veloce e stupido: combinazione letale per un perdente come te!",
            "La fisica ti odia quasi quanto me!",
            "Il tuo slancio Ã¨ proporzionale alla tua stupiditÃ : immenso!",
            "Continua a sbracciarti cosÃ¬, idiota, Ã¨ esilarante!"
        ]
    },
    "general_mockery": {
        "en": [
            "Is this your first day being alive? Because you're terrible!",
            "You MIGHT do better... in another lifetime!",
            "Keep trying? Nah, just quit while you're hopelessly behind!",
            "My blind, dead grandma plays better than your garbage!",
            "You're not just badâ€”you're an insult to bad players!",
            "This is excruciatingâ€”like watching paint dry on a corpse!",
            "Trying? Looks more like deliberate self-sabotage!",
            "Tutorial bots laugh at your pathetic attempts!",
            "Yawn. Wake me when you stop being a complete joke.",
            "Just quitâ€”save us all from your disgraceful display!",
            "This isn't going well? It's going exactly as your skill predicts: disaster!",
            "I'm barely awake and still destroying your ego!",
            "HOW are you this catastrophically awful?!",
            "Delete the game, delete your account, delete yourself!",
            "Your high score is a war crime against gaming!",
            "Easier difficulty? There isn't one low enough for you!",
            "Mobile gaming calledâ€”it doesn't want you either!",
            "UNINSTALL AND NEVER RETURN, YOU HOPELESS DISASTER!"
        ],
        "it": [
            "Ãˆ il tuo primo giorno da vivo? PerchÃ© fai troppo schifo!",
            "Ma tu hai mai vinto qualcosa in vita tua o solo perso?",
            "Giochi come se le dita fossero incollate col bostik!",
            "POTRESTI fare meglio... forse in un'altra vita!",
            "Il tuo livello Ã¨ cosÃ¬ basso che serve un sottomarino per trovarlo!",
            "Mia zia con l'artrite ti umilierebbe senza fatica!",
            "Continua a provare? No, molla finchÃ© sei irrimediabilmente indietro!",
            "Guardarti giocare Ã¨ una tortura peggiore dell'inferno!",
            "Mia nonna cieca e morta gioca meglio di te!",
            "Non sei solo scarso, sei un insulto ai giocatori scarsi!",
            "Ci provi almeno o Ã¨ solo masochismo puro?",
            "Spiegami una cosa, sei scarso o ti stai sabotando da solo?",
            "Molla, tanto sei nato per perdere, non forzare la natura!",
            "Per favore mi svegli quando smetti di essere una barzelletta totale?",
            "Mollaâ€”risparmiaci tutti dalla tua esibizione vergognosa!",
            "Sei un insulto all'evoluzione umana!",
            "Cancella l'app e vai a zappare la terra, almeno lÃ¬ servi!",
            "Non sta andando bene? Tranquillo, le mie aspettative sono molto piÃ¹ basse!",
            "Hai fatto un corso per imparare a fare cosÃ¬ schifo?",
            "DifficoltÃ  facile? Per te servirebbe 'modalitÃ  vegetale'!",
            "Cancella il gioco, cancella l'account, cancella te stesso!",
            "Il tuo record Ã¨ un crimine di guerra contro il gaming!",
            "DifficoltÃ  piÃ¹ facile? Non ne esiste una abbastanza bassa per te!",
            "FATTI UNA CORTESIA: DISINSTALLA E NON TORNARE MAI PIÃ™!"
        ]
    },
    "near_death": {
        "en": [
            "One more hit and you're finished, you fragile joke!",
            "Just surrender alreadyâ€”spare me the pathetic struggle!",
            "Watching you cling to life is honestly embarrassing!",
            "You're done. Accept your utter worthlessness.",
            "Last life? You'll waste it like everything else!",
            "Victory tastes so sweetâ€”your tears will make it sweeter!",
            "Defeat is inevitable, you delusional failure!",
            "Survival? That's a word real players use!"
        ],
        "it": [
            "Un altro colpo e sei storia, relitto umano!",
            "Rinuncia! Risparmiaci questo spettacolo patetico!",
            "Non resistere, tanto sei giÃ  morto dentro!",
            "Guardarti aggrappato alla vita, Ã¨ sinceramente imbarazzante!",
            "Hai finito? Accetta la tua totale inutilitÃ  e torna a casa.",
            "La sconfitta ti sta bene, indossala con orgoglio!",
            "Ultima vita? La sprecherai come hai fatto per tutta la tua esistenza!",
            "Sopravvivere non Ã¨ roba per fenomeni come te!",
            "La tua ultima vita ti costerÃ  il prezzo di un funerale!",
            "La vittoria Ã¨ cosÃ¬ dolce, le tue lacrime la renderanno ancora piÃ¹ dolce!"
        ]
    },
    "final_death": {
        "en": [
            "GAME OVER! You're irredeemable trash!",
            "Dead. Pathetic. Expected. Next loser, please!",
            "I KNEW you were too incompetent to win!",
            "Thanks for the laughs, you monumental failure!",
            "Better luck next time? No, there won't be one for you!",
            "Victory is mineâ€”you never even belonged here!",
            "You had zero chance from the start, idiot!",
            "Wow. That was the most embarrassing death I've ever seen."
        ],
        "it": [
            "Riposa in pace, bollito!",
            "Il mondo ringrazia per la tua dipartita!",            "Anche questa Ã¨ andata. Prossimo perdente, prego!",
            "SAPEVO che eri troppo incompetente per vincere!",
            "Morto e sepolto, esattamente come il tuo talento!",
            "Lo sapevo: eri troppo scarso per farcela!",
            "Grazie per avermi fatto ridere",
            "Grazie per le risate, fallimento monumentale!",
            "Buona fortuna la prossima volta? Avrai bisogno di un miracolo!",
            "Dai... avanti che ci avevi creduto.",
            "La morte piÃ¹ ridicola che abbia mai visto, complimenti!"
        ]
    },
    "fall_off_edge": {
        "en": [
            "SPLAT! You absolute moron!",
            "Down you goâ€”good riddance, trash!",
            "Gravity finally did us all a favor!",
            "Farewell, you clumsy waste of code!",
            "Butterfingers? More like butter-brain!",
            "Careless idiot gets exactly what he deserves!",
            "Enjoy the endless fall, you worthless player!",
            "Didn't even need to hit youâ€”you failed yourself!"
        ],
        "it": [
            "SPLASH! Che botta!",
            "Addio, disastro con le gambe!",
            "La gravitÃ  ci ha finalmente fatto un favore!",
            "Caduto come la tua autostima: di botto!",
            "Addio, spreco di ossigeno!",
            "Mani di burro? Il cervello sarÃ  olio d'oliva!",
            "Idiota disattento ottiene esattamente ciÃ² che merita!",
            "Goditi il viaggio verso l'oblio, perdente!",
            "Non ho neanche dovuto mirare: hai fatto tutto tu!"
        ]
    },
    "difficulty_increase": {
        "2": {
            "en": [
                "Survived easy mode? Time to watch you crumble!",
                "Thought that was hard? You're about to cry!",
                "Turning up the heatâ€”prepare for humiliation!",
                "Medium difficulty for the eternally mediocreâ€”you!"
            ],
            "it": [
                "Sopravvissuto alla modalitÃ  facile? Sei piÃ¹ intelligente di un macaco!",
                "Pensavi fosse difficile? Ora piangerai!",
                "Si alza il livello, preparati all'umiliazione!",
                "DifficoltÃ  media per giocatori mediocri!"
            ]
        },
        "3": {
            "en": [
                "Hard mode! Your suffering begins now!",
                "Still alive? That changes in 3... 2... 1...",
                "Real game startsâ€”real players only, sorry!",
                "Your survival was cute while it lasted!"
            ],
            "it": [
                "ModalitÃ  difficile! Adesso mi alzo dalla sedia!",
                "ModalitÃ  difficile: qui muoiono i deboli come te!",
                "Ancora vivo? Errore temporaneo, correggo subito!",
                "Ancora vivo? CambierÃ  in 3... 2... 1...",
                "Il vero gioco inizia, i perdenti escono di scena!",
                "La tua agonia diventa seria, che goduria!",
                "La tua sopravvivenza era carina finchÃ© Ã¨ durata!"
            ]
        },
        "4": {
            "en": [
                "BRUTAL MODEâ€”your nightmare just got real!",
                "Maximum pain incomingâ€”pray for a quick death!",
                "No mercy, no hope, just your inevitable doom!",
                "You made it here? Impressive... said no one ever!"
            ],
            "it": [
                "MODALITÃ€ BRUTALE, ora mammina ti fa male!",
                "BRUTALE! Sei giÃ  morto, solo non lo sai ancora!",
                "Massima difficoltÃ : prega, tanto non serve!",
                "Dolore massimo in arrivo. Prega per una morte veloce!",
                "Nessuna pietÃ , nessuna speranza, il riassunto della tua vita!",
                "Niente pietÃ  per gli scarsetti come te!",
                "Sei arrivato qui? Che persona incredibile... ha detto nessuno mai!"
            ]
        }
    }
};
const TAUNTS_AUDIO = {"Sei un fallimento totale. Pagliaccio!":"audio/taunts/it/edge_proximity_00.mp3?v=1770430173129","Barcolli come il nulla che sei. CADI CHE RISPARMIAMO TEMPO!":"audio/taunts/it/edge_proximity_01.mp3?v=1770430173129","Un altro millimetro e finisci nel dimenticatoio, fenomeno da baraccone!":"audio/taunts/it/edge_proximity_02.mp3?v=1770430173129","CosÃ¬ vicino al bordo... una metafora sulla tua vita!":"audio/taunts/it/edge_proximity_03.mp3?v=1770430173129","Sento quasi il tuo patetico cuoricino accelerare!":"audio/taunts/it/edge_proximity_04.mp3?v=1770430173129","Il vuoto ti sta chiamando per nome, rispondigli, codardo!":"audio/taunts/it/edge_proximity_05.mp3?v=1770430173129","Il vuoto ti implora, sei uno spreco di ossigeno!":"audio/taunts/it/edge_proximity_06.mp3?v=1770430173129","Dai, sporgiti un po' di piÃ¹, tanto sei giÃ  un fallito!":"audio/taunts/it/edge_proximity_07.mp3?v=1770430173129","Palmi sudati? Ãˆ il sapore della sconfitta inevitabile!":"audio/taunts/it/edge_proximity_08.mp3?v=1770430173129","Dai, sporgiti, solo un altro po', cane senza appello!":"audio/taunts/it/edge_proximity_09.mp3?v=1770430173129","Un piccolo scivolone e addio al peggior giocatore del pianeta!":"audio/taunts/it/edge_proximity_10.mp3?v=1770430173129","Sull'orlo della gloria? PiÃ¹ sull'orlo della tua fine senza senso!":"audio/taunts/it/edge_proximity_11.mp3?v=1770430173129","Ti vedo barcollare come la tua autostima: zero equilibrio!":"audio/taunts/it/edge_proximity_12.mp3?v=1770430173129","Un passetto e sparisci per sempre. Fatti questo favore!":"audio/taunts/it/edge_proximity_13.mp3?v=1770430173129","Guardarti barcollare Ã¨ l'unica gioia dal tuo gioco schifoso!":"audio/taunts/it/edge_proximity_14.mp3?v=1770430173129","Precipita! Verme senza spina dorsale!":"audio/taunts/it/edge_proximity_15.mp3?v=1770430173129","L'abisso ha fame e tu sei lo spuntino perfetto.!":"audio/taunts/it/edge_proximity_16.mp3?v=1770430173129","Colpo diretto, sacco flaccido di fallimento!":"audio/taunts/it/after_hit_00.mp3?v=1770430173129","Ahi, quello ha fatto male... alla tua dignitÃ , soprattutto!":"audio/taunts/it/after_hit_01.mp3?v=1770430173129","Sei piÃ¹ lento di un bradipo morto!":"audio/taunts/it/after_hit_02.mp3?v=1770430173129","HAHA! Te lo sei preso dritto in faccia, vero, perdente?":"audio/taunts/it/after_hit_03.mp3?v=1770430173129","Questo avrÃ  fatto piÃ¹ male al tuo ego che ad altro!":"audio/taunts/it/after_hit_04.mp3?v=1770430173129","Ho visto statue piÃ¹ mobili di te!":"audio/taunts/it/after_hit_05.mp3?v=1770430173129","Centro perfetto sul re dei perdenti, che onore per me!":"audio/taunts/it/after_hit_06.mp3?v=1770430173129","Troppo lento, troppo stupido, totalmente patetico!":"audio/taunts/it/after_hit_07.mp3?v=1770430173129","I tuoi riflessi meritano un museo del fallimento!":"audio/taunts/it/after_hit_08.mp3?v=1770430173129","Centro perfetto sul peggior giocatore del mondo, complimenti... spazzatura!":"audio/taunts/it/after_hit_09.mp3?v=1770430173129","Non stai neanche provando a nascondere quanto fai schifo!":"audio/taunts/it/after_hit_10.mp3?v=1770430173129","Come fai a essere cosÃ¬ inutile?!":"audio/taunts/it/after_hit_11.mp3?v=1770430173129","Ehi, calmati, la morte sta arrivando!":"audio/taunts/it/reckless_movement_00.mp3?v=1770430173129","Spericolato? PiÃ¹ che altro suicida con zero stile!":"audio/taunts/it/reckless_movement_01.mp3?v=1770430173129","Corri come se avessi un cervello... ah no, scusa, non ce l'hai!":"audio/taunts/it/reckless_movement_02.mp3?v=1770430173129","Vai forte, eh? Peccato che la competenza non tenga il passo!":"audio/taunts/it/reckless_movement_03.mp3?v=1770430173129","Rallenta prima di imbarazzarti ancora di piÃ¹!":"audio/taunts/it/reckless_movement_04.mp3?v=1770430173129","Guarda come vai dritto verso l'umiliazione totale!":"audio/taunts/it/reckless_movement_05.mp3?v=1770430173129","Veloce e stupido: combinazione letale per un perdente come te!":"audio/taunts/it/reckless_movement_06.mp3?v=1770430173129","La fisica ti odia quasi quanto me!":"audio/taunts/it/reckless_movement_07.mp3?v=1770430173129","Il tuo slancio Ã¨ proporzionale alla tua stupiditÃ : immenso!":"audio/taunts/it/reckless_movement_08.mp3?v=1770430173129","Continua a sbracciarti cosÃ¬, idiota, Ã¨ esilarante!":"audio/taunts/it/reckless_movement_09.mp3?v=1770430173129","Ãˆ il tuo primo giorno da vivo? PerchÃ© fai troppo schifo!":"audio/taunts/it/general_mockery_00.mp3?v=1770430173129","Ma tu hai mai vinto qualcosa in vita tua o solo perso?":"audio/taunts/it/general_mockery_01.mp3?v=1770430173129","Giochi come se le dita fossero incollate col bostik!":"audio/taunts/it/general_mockery_02.mp3?v=1770430173129","POTRESTI fare meglio... forse in un'altra vita!":"audio/taunts/it/general_mockery_03.mp3?v=1770430173129","Il tuo livello Ã¨ cosÃ¬ basso che serve un sottomarino per trovarlo!":"audio/taunts/it/general_mockery_04.mp3?v=1770430173129","Mia zia con l'artrite ti umilierebbe senza fatica!":"audio/taunts/it/general_mockery_05.mp3?v=1770430173129","Continua a provare? No, molla finchÃ© sei irrimediabilmente indietro!":"audio/taunts/it/general_mockery_06.mp3?v=1770430173129","Guardarti giocare Ã¨ una tortura peggiore dell'inferno!":"audio/taunts/it/general_mockery_07.mp3?v=1770430173129","Mia nonna cieca e morta gioca meglio di te!":"audio/taunts/it/general_mockery_08.mp3?v=1770430173129","Non sei solo scarso, sei un insulto ai giocatori scarsi!":"audio/taunts/it/general_mockery_09.mp3?v=1770430173129","Ci provi almeno o Ã¨ solo masochismo puro?":"audio/taunts/it/general_mockery_10.mp3?v=1770430173129","Spiegami una cosa, sei scarso o ti stai sabotando da solo?":"audio/taunts/it/general_mockery_11.mp3?v=1770430173129","Molla, tanto sei nato per perdere, non forzare la natura!":"audio/taunts/it/general_mockery_12.mp3?v=1770430173129","Per favore mi svegli quando smetti di essere una barzelletta totale?":"audio/taunts/it/general_mockery_13.mp3?v=1770430173129","Mollaâ€”risparmiaci tutti dalla tua esibizione vergognosa!":"audio/taunts/it/general_mockery_14.mp3?v=1770430173129","Sei un insulto all'evoluzione umana!":"audio/taunts/it/general_mockery_15.mp3?v=1770430173129","Cancella l'app e vai a zappare la terra, almeno lÃ¬ servi!":"audio/taunts/it/general_mockery_16.mp3?v=1770430173129","Non sta andando bene? Tranquillo, le mie aspettative sono molto piÃ¹ basse!":"audio/taunts/it/general_mockery_17.mp3?v=1770430173129","Hai fatto un corso per imparare a fare cosÃ¬ schifo?":"audio/taunts/it/general_mockery_18.mp3?v=1770430173129","DifficoltÃ  facile? Per te servirebbe 'modalitÃ  vegetale'!":"audio/taunts/it/general_mockery_19.mp3?v=1770430173129","Cancella il gioco, cancella l'account, cancella te stesso!":"audio/taunts/it/general_mockery_20.mp3?v=1770430173129","Il tuo record Ã¨ un crimine di guerra contro il gaming!":"audio/taunts/it/general_mockery_21.mp3?v=1770430173129","DifficoltÃ  piÃ¹ facile? Non ne esiste una abbastanza bassa per te!":"audio/taunts/it/general_mockery_22.mp3?v=1770430173129","FATTI UNA CORTESIA: DISINSTALLA E NON TORNARE MAI PIÃ™!":"audio/taunts/it/general_mockery_23.mp3?v=1770430173129","Un altro colpo e sei storia, relitto umano!":"audio/taunts/it/near_death_00.mp3?v=1770430173129","Rinuncia! Risparmiaci questo spettacolo patetico!":"audio/taunts/it/near_death_01.mp3?v=1770430173129","Non resistere, tanto sei giÃ  morto dentro!":"audio/taunts/it/near_death_02.mp3?v=1770430173129","Guardarti aggrappato alla vita, Ã¨ sinceramente imbarazzante!":"audio/taunts/it/near_death_03.mp3?v=1770430173129","Hai finito? Accetta la tua totale inutilitÃ  e torna a casa.":"audio/taunts/it/near_death_04.mp3?v=1770430173129","La sconfitta ti sta bene, indossala con orgoglio!":"audio/taunts/it/near_death_05.mp3?v=1770430173129","Ultima vita? La sprecherai come hai fatto per tutta la tua esistenza!":"audio/taunts/it/near_death_06.mp3?v=1770430173129","Sopravvivere non Ã¨ roba per fenomeni come te!":"audio/taunts/it/near_death_07.mp3?v=1770430173129","La tua ultima vita ti costerÃ  il prezzo di un funerale!":"audio/taunts/it/near_death_08.mp3?v=1770430173129","La vittoria Ã¨ cosÃ¬ dolce, le tue lacrime la renderanno ancora piÃ¹ dolce!":"audio/taunts/it/near_death_09.mp3?v=1770430173129","Riposa in pace, bollito!":"audio/taunts/it/final_death_00.mp3?v=1770430173129","Il mondo ringrazia per la tua dipartita!":"audio/taunts/it/final_death_01.mp3?v=1770430173129","Anche questa Ã¨ andata. Prossimo perdente, prego!":"audio/taunts/it/final_death_02.mp3?v=1770430173129","SAPEVO che eri troppo incompetente per vincere!":"audio/taunts/it/final_death_03.mp3?v=1770430173129","Morto e sepolto, esattamente come il tuo talento!":"audio/taunts/it/final_death_04.mp3?v=1770430173129","Lo sapevo: eri troppo scarso per farcela!":"audio/taunts/it/final_death_05.mp3?v=1770430173129","Grazie per avermi fatto ridere":"audio/taunts/it/final_death_06.mp3?v=1770430173129","Grazie per le risate, fallimento monumentale!":"audio/taunts/it/final_death_07.mp3?v=1770430173129","Buona fortuna la prossima volta? Avrai bisogno di un miracolo!":"audio/taunts/it/final_death_08.mp3?v=1770430173129","Dai... avanti che ci avevi creduto.":"audio/taunts/it/final_death_09.mp3?v=1770430173129","La morte piÃ¹ ridicola che abbia mai visto, complimenti!":"audio/taunts/it/final_death_10.mp3?v=1770430173129","SPLASH! Che botta!":"audio/taunts/it/fall_off_edge_00.mp3?v=1770430173129","Addio, disastro con le gambe!":"audio/taunts/it/fall_off_edge_01.mp3?v=1770430173129","La gravitÃ  ci ha finalmente fatto un favore!":"audio/taunts/it/fall_off_edge_02.mp3?v=1770430173129","Caduto come la tua autostima: di botto!":"audio/taunts/it/fall_off_edge_03.mp3?v=1770430173129","Addio, spreco di ossigeno!":"audio/taunts/it/fall_off_edge_04.mp3?v=1770430173129","Mani di burro? Il cervello sarÃ  olio d'oliva!":"audio/taunts/it/fall_off_edge_05.mp3?v=1770430173129","Idiota disattento ottiene esattamente ciÃ² che merita!":"audio/taunts/it/fall_off_edge_06.mp3?v=1770430173129","Goditi il viaggio verso l'oblio, perdente!":"audio/taunts/it/fall_off_edge_07.mp3?v=1770430173129","Non ho neanche dovuto mirare: hai fatto tutto tu!":"audio/taunts/it/fall_off_edge_08.mp3?v=1770430173129","Sopravvissuto alla modalitÃ  facile? Sei piÃ¹ intelligente di un macaco!":"audio/taunts/it/difficulty_increase_2_00.mp3?v=1770430173129","Pensavi fosse difficile? Ora piangerai!":"audio/taunts/it/difficulty_increase_2_01.mp3?v=1770430173129","Si alza il livello, preparati all'umiliazione!":"audio/taunts/it/difficulty_increase_2_02.mp3?v=1770430173129","DifficoltÃ  media per giocatori mediocri!":"audio/taunts/it/difficulty_increase_2_03.mp3?v=1770430173129","ModalitÃ  difficile! Adesso mi alzo dalla sedia!":"audio/taunts/it/difficulty_increase_3_00.mp3?v=1770430173129","ModalitÃ  difficile: qui muoiono i deboli come te!":"audio/taunts/it/difficulty_increase_3_01.mp3?v=1770430173129","Ancora vivo? Errore temporaneo, correggo subito!":"audio/taunts/it/difficulty_increase_3_02.mp3?v=1770430173129","Ancora vivo? CambierÃ  in 3... 2... 1...":"audio/taunts/it/difficulty_increase_3_03.mp3?v=1770430173129","Il vero gioco inizia, i perdenti escono di scena!":"audio/taunts/it/difficulty_increase_3_04.mp3?v=1770430173129","La tua agonia diventa seria, che goduria!":"audio/taunts/it/difficulty_increase_3_05.mp3?v=1770430173129","La tua sopravvivenza era carina finchÃ© Ã¨ durata!":"audio/taunts/it/difficulty_increase_3_06.mp3?v=1770430173129","MODALITÃ€ BRUTALE, ora mammina ti fa male!":"audio/taunts/it/difficulty_increase_4_00.mp3?v=1770430173129","BRUTALE! Sei giÃ  morto, solo non lo sai ancora!":"audio/taunts/it/difficulty_increase_4_01.mp3?v=1770430173129","Massima difficoltÃ : prega, tanto non serve!":"audio/taunts/it/difficulty_increase_4_02.mp3?v=1770430173129","Dolore massimo in arrivo. Prega per una morte veloce!":"audio/taunts/it/difficulty_increase_4_03.mp3?v=1770430173129","Nessuna pietÃ , nessuna speranza, il riassunto della tua vita!":"audio/taunts/it/difficulty_increase_4_04.mp3?v=1770430173129","Niente pietÃ  per gli scarsetti come te!":"audio/taunts/it/difficulty_increase_4_05.mp3?v=1770430173129","Sei arrivato qui? Che persona incredibile... ha detto nessuno mai!":"audio/taunts/it/difficulty_increase_4_06.mp3?v=1770430173129"};

// ========== config.js ==========
/**
 * Lablix - Configuration and Constants
 */

const PLATFORM_WIDTH = 12;
const PLATFORM_DEPTH = 12;
const PLATFORM_HEIGHT = 0.5;
const PLATFORM_ELEVATION = 0;

const FRICTION = 0.92;
const ACCELERATION = 0.015;
const MAX_VELOCITY = 0.30;
const BOX_SIZE = 1;
const FALL_GRAVITY = 0.015;

const gameState = {
    score: 0,
    lives: 5,
    highScore: 0,
    currentScreen: 'start',
    isPlaying: false,
    isMobile: false,
    initialized: false,
    velocity: { x: 0, z: 0 },
    acceleration: { x: 0, z: 0 },
    isOnPlatform: true,
    isFalling: false,
    fallVelocity: 0,
    fallRotation: { x: 0, z: 0 },
    calibration: { beta: 0, gamma: 0 },
    gyro: { beta: 0, gamma: 0 },
    tilt: { x: 0, z: 0 },
    gyroReceived: false,
    playerBox: null,
    // Enemy & Combat (Phases 7-10)
    enemy: null,
    enemyPillar: null,
    projectiles: [],
    lastShotTime: 0,
    difficultyTier: 1,
    // Taunt system
    lastTauntTime: 0,
    currentTaunt: null,
    // Hit detection
    isHit: false,
    hitCooldown: 0,
    lastHitTime: 0
};

let scene, camera, renderer, platformEdges;
let wakeLock = null;
let tempQuaternion, rotationAxis;
let startScreen, calibrationScreen, gameContainer;


// ========== translations.js ==========
/**
 * Lablix - Multilingual Translation System
 */

const LANGUAGES = {
    en: {
        code: 'en',
        name: 'English',
        flag: 'ðŸ‡¬ðŸ‡§',
        voices: ['Google US English', 'Google UK English Female', 'Microsoft Aria Online (Natural)', 'Samantha']
    },
    it: {
        code: 'it',
        name: 'Italiano',
        flag: 'ðŸ‡®ðŸ‡¹',
        voices: ['Google italiano', 'Microsoft Elsa', 'Alice', 'Federica']
    }
};

const TRANSLATIONS = {
    // UI Text
    ui: {
        title: {
            en: 'LABLIX',
            it: 'LABLIX'
        },
        tagline: {
            en: "Tilt to survive. Don't fall.",
            it: "Inclina per sopravvivere. Non cadere."
        },
        instruction1: {
            en: 'Tilt your phone to move',
            it: 'Inclina il telefono per muoverti'
        },
        instruction2: {
            en: "Don't fall off the edge",
            it: "Non cadere dal bordo"
        },
        instruction3: {
            en: 'Collect coins to score',
            it: 'Raccogli monete per fare punti'
        },
        calibrationHint: {
            en: 'This position will be your neutral (no tilt)',
            it: 'Questa posizione sarÃ  la tua posizione neutra (senza inclinazione)'
        },
        play: {
            en: 'PLAY',
            it: 'GIOCA'
        },
        highScore: {
            en: 'High Score',
            it: 'Record'
        },
        score: {
            en: 'SCORE',
            it: 'PUNTI'
        },
        lives: {
            en: 'Lives',
            it: 'Vite'
        },
        calibrate: {
            en: 'CALIBRATE',
            it: 'CALIBRA'
        },
        calibrating: {
            en: 'Calibrating...',
            it: 'Calibrazione...'
        },
        calibrationInstructions: {
            en: 'Hold your device flat and steady',
            it: 'Tieni il dispositivo piatto e fermo'
        },
        exit: {
            en: 'EXIT',
            it: 'ESCI'
        },
        back: {
            en: 'BACK',
            it: 'INDIETRO'
        },
        gameOver: {
            en: 'GAME OVER',
            it: 'FINE PARTITA'
        },
        youFell: {
            en: 'You Fell Off!',
            it: 'Sei Caduto!'
        },
        youWereHit: {
            en: 'You Were Hit!',
            it: 'Sei Stato Colpito!'
        },
        playAgain: {
            en: 'PLAY AGAIN',
            it: 'RIGIOCA'
        },
        mobileOnly: {
            en: 'This game requires a mobile device with gyroscope.',
            it: 'Questo gioco richiede un dispositivo mobile con giroscopio.'
        },
        gyroPermission: {
            en: 'Gyroscope permission is required to play.',
            it: 'Ãˆ necessario il permesso del giroscopio per giocare.'
        },
        // Difficulty tiers
        tierLabel: {
            en: 'TIER',
            it: 'LIVELLO'
        },
        difficultyEasy: {
            en: 'EASY',
            it: 'FACILE'
        },
        difficultyMedium: {
            en: 'MEDIUM',
            it: 'MEDIO'
        },
        difficultyHard: {
            en: 'HARD',
            it: 'DIFFICILE'
        },
        difficultyBrutal: {
            en: 'BRUTAL',
            it: 'BRUTALE'
        },
        difficultyIncreased: {
            en: 'DIFFICULTY INCREASED',
            it: 'DIFFICOLTÃ€ AUMENTATA'
        },
        // Calibration screen
        holdFlat: {
            en: 'HOLD FLAT',
            it: 'TIENI PIATTO'
        },
        ready: {
            en: 'READY!',
            it: 'PRONTO!'
        },
        calibrationMsgFlat: {
            en: 'Great! This position is your neutral balance point',
            it: 'Perfetto! Questa posizione Ã¨ il tuo punto di equilibrio'
        },
        calibrationMsgTilt: {
            en: 'Place your phone flat on a table or hold it level',
            it: 'Tieni il telefono in piano, come se volessi fotografare i piedi'
        },
        calibrationHintFlat: {
            en: 'Tap START NOW to begin!',
            it: 'Tocca INIZIA ORA per cominciare!'
        },
        calibrationHintTilt: {
            en: 'Tilt gently until the dot is centered',
            it: 'Inclina piano fino a centrare il punto'
        },
        gyroCheckFlat: {
            en: 'Perfect! Phone is level',
            it: 'Perfetto! Il telefono Ã¨ in piano'
        },
        gyroNotDetected: {
            en: 'Not detected',
            it: 'Non rilevato'
        },
        gyroWaiting: {
            en: 'Waiting for gyroscope...',
            it: 'In attesa del giroscopio...'
        },
        startNow: {
            en: 'START NOW',
            it: 'INIZIA ORA'
        },
        creditsLabel: {
            en: 'Ideator & Creator',
            it: 'Ideatore & Creatore'
        }
    }
};

// Current language
let currentLanguage = 'en';

function initLanguage() {
    // Check localStorage first
    const saved = localStorage.getItem('lablix_language');
    if (saved && LANGUAGES[saved]) {
        currentLanguage = saved;
        return;
    }

    // Detect browser language
    const browserLang = navigator.language || navigator.userLanguage;
    const langCode = browserLang.split('-')[0].toLowerCase();

    if (LANGUAGES[langCode]) {
        currentLanguage = langCode;
    } else {
        currentLanguage = 'en';
    }

    localStorage.setItem('lablix_language', currentLanguage);
}

function setLanguage(langCode) {
    if (!LANGUAGES[langCode]) return;
    currentLanguage = langCode;
    localStorage.setItem('lablix_language', currentLanguage);
    updateAllText();
    updateVoiceForLanguage();
}

function getLanguage() {
    return currentLanguage;
}

function getText(category, key) {
    const cat = TRANSLATIONS[category];
    if (!cat) return key;
    const item = cat[key];
    if (!item) return key;
    return item[currentLanguage] || item['en'] || key;
}

function getTaunt(category) {
    if (typeof TAUNTS_DATA === 'undefined') return null;
    const cat = TAUNTS_DATA[category];
    if (!cat) return null;

    const taunts = cat[currentLanguage] || cat['en'];
    if (!taunts || taunts.length === 0) return null;
    return taunts[Math.floor(Math.random() * taunts.length)];
}

function getDifficultyTaunt(tier) {
    if (typeof TAUNTS_DATA === 'undefined') return null;
    const taunts = TAUNTS_DATA.difficulty_increase[tier];
    if (!taunts) return null;
    const pool = taunts[currentLanguage] || taunts['en'];
    if (!pool || pool.length === 0) return null;
    return pool[Math.floor(Math.random() * pool.length)];
}

function updateAllText() {
    // Update all UI elements with data-i18n="category.key" attribute
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const parts = el.dataset.i18n.split('.');
        if (parts.length === 2) {
            el.textContent = getText(parts[0], parts[1]);
        }
    });

    // Update all UI elements with data-i18n-key="key" attribute (uses 'ui' category)
    document.querySelectorAll('[data-i18n-key]').forEach(el => {
        const key = el.dataset.i18nKey;
        el.textContent = getText('ui', key);
    });

    // Update language selector display
    const selector = document.getElementById('language-selector');
    if (selector) {
        const lang = LANGUAGES[currentLanguage];
        const display = selector.querySelector('.lang-display');
        if (display) {
            display.innerHTML = `${lang.flag} ${lang.name}`;
        }
    }
}

function initLanguageSelector() {
    const selector = document.getElementById('language-selector');
    if (!selector) return;

    const display = selector.querySelector('.lang-display');
    const options = selector.querySelectorAll('.lang-option');

    // Update display with current language
    const lang = LANGUAGES[currentLanguage];
    if (display && lang) {
        display.textContent = `${lang.flag} ${lang.name}`;
    }

    // Update selected state
    options.forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.lang === currentLanguage);
    });

    // Toggle dropdown on click
    if (display) {
        display.addEventListener('click', (e) => {
            e.stopPropagation();
            selector.classList.toggle('open');
        });
    }

    // Select language on option click
    options.forEach(opt => {
        opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const langCode = opt.dataset.lang;
            setLanguage(langCode);
            selector.classList.remove('open');

            // Update display
            const newLang = LANGUAGES[langCode];
            if (display && newLang) {
                display.textContent = `${newLang.flag} ${newLang.name}`;
            }

            // Update selected state
            options.forEach(o => o.classList.toggle('selected', o.dataset.lang === langCode));
        });
    });

    // Close dropdown on outside click
    document.addEventListener('click', (e) => {
        if (!selector.contains(e.target)) {
            selector.classList.remove('open');
        }
    });
}

function updateVoiceForLanguage() {
    // This will be called to update the speech voice
    if (typeof updateSpeechVoice === 'function') {
        updateSpeechVoice();
    }
}


// ========== scene.js ==========
/**
 * Lablix - Three.js Scene Setup
 * Universe background with animated cosmic events
 */

var bgEffects = [];

function initThreeJS() {
    if (scene) return;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020010);
    scene.fog = new THREE.Fog(0x020010, 30, 80);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(aspect < 1 ? 75 : 60, aspect, 0.1, 1000);
    camera.position.set(0, 18, 14);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    gameContainer.appendChild(renderer.domElement);

    createLighting();
    createPlatform();
    createStarfield();
    createPlayerBox();

    window.addEventListener('resize', onWindowResize);
}

function createLighting() {
    scene.add(new THREE.AmbientLight(0x404060, 0.5));

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainLight.position.set(10, 20, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(2048, 2048);
    scene.add(mainLight);

    const rimLight = new THREE.DirectionalLight(0x667eea, 0.4);
    rimLight.position.set(-10, 5, -10);
    scene.add(rimLight);
}

// ========== GRASS PLATFORM ==========

function createGrassTexture() {
    var c = document.createElement('canvas');
    c.width = 512; c.height = 512;
    var ctx = c.getContext('2d');

    // Base green
    ctx.fillStyle = '#2a6e1e';
    ctx.fillRect(0, 0, 512, 512);

    // Patches of darker/lighter green
    for (var i = 0; i < 80; i++) {
        var x = Math.random() * 512;
        var y = Math.random() * 512;
        var r = 15 + Math.random() * 40;
        var g = ctx.createRadialGradient(x, y, 0, x, y, r);
        var shade = Math.random() > 0.5 ? '#3d8f2e' : '#2e7a20';
        g.addColorStop(0, shade);
        g.addColorStop(1, 'transparent');
        ctx.fillStyle = g;
        ctx.fillRect(x - r, y - r, r * 2, r * 2);
    }

    // Grass blades
    for (var j = 0; j < 600; j++) {
        var bx = Math.random() * 512;
        var by = Math.random() * 512;
        var bl = 4 + Math.random() * 10;
        var angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
        ctx.strokeStyle = 'rgba(' +
            Math.floor(30 + Math.random() * 40) + ',' +
            Math.floor(90 + Math.random() * 80) + ',' +
            Math.floor(10 + Math.random() * 30) + ',0.7)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + Math.cos(angle) * bl, by + Math.sin(angle) * bl);
        ctx.stroke();
    }

    // Small flowers / dots
    for (var k = 0; k < 20; k++) {
        var fx = Math.random() * 512;
        var fy = Math.random() * 512;
        ctx.fillStyle = ['#f0e68c', '#ffffff', '#dda0dd', '#ffb6c1'][Math.floor(Math.random() * 4)];
        ctx.beginPath();
        ctx.arc(fx, fy, 1.5 + Math.random(), 0, Math.PI * 2);
        ctx.fill();
    }

    var tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, 2);
    return tex;
}

function createPlatform() {
    var platformGeo = new THREE.BoxGeometry(PLATFORM_WIDTH, PLATFORM_HEIGHT, PLATFORM_DEPTH);

    // Grass on top, dirt on sides
    var grassTex = createGrassTexture();
    var topMat = new THREE.MeshStandardMaterial({ map: grassTex, roughness: 0.95 });
    var sideMat = new THREE.MeshStandardMaterial({ color: 0x5c3a1e, roughness: 0.9 });

    // BoxGeometry faces: +x, -x, +y, -y, +z, -z
    var mats = [sideMat, sideMat, topMat, sideMat, sideMat, sideMat];
    var platform = new THREE.Mesh(platformGeo, mats);
    platform.position.y = -PLATFORM_HEIGHT / 2;
    platform.receiveShadow = true;
    scene.add(platform);

    var edgeMat = new THREE.MeshBasicMaterial({ color: 0xff4757, transparent: true, opacity: 0.9 });
    platformEdges = [];

    var addEdge = function(w, d, x, z) {
        var edge = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d), edgeMat);
        edge.position.set(x, 0, z);
        scene.add(edge);
        platformEdges.push(edge);
    };

    addEdge(PLATFORM_WIDTH + 0.3, 0.15, 0, PLATFORM_DEPTH / 2 + 0.075);
    addEdge(PLATFORM_WIDTH + 0.3, 0.15, 0, -PLATFORM_DEPTH / 2 - 0.075);
    addEdge(0.15, PLATFORM_DEPTH, -PLATFORM_WIDTH / 2 - 0.075, 0);
    addEdge(0.15, PLATFORM_DEPTH, PLATFORM_WIDTH / 2 + 0.075, 0);
}

// ========== STARFIELD ==========

function createStarfield() {
    // Dense starfield â€” white/blue/warm stars at varying depths
    var count = 1200;
    var geo = new THREE.BufferGeometry();
    var pos = new Float32Array(count * 3);
    var colors = new Float32Array(count * 3);
    var sizes = new Float32Array(count);

    for (var i = 0; i < count; i++) {
        pos[i * 3]     = (Math.random() - 0.5) * 140;
        pos[i * 3 + 1] = -10 - Math.random() * 60;
        pos[i * 3 + 2] = (Math.random() - 0.5) * 140;

        // Star color variety
        var t = Math.random();
        if (t < 0.6) {
            // White
            colors[i * 3] = 0.9 + Math.random() * 0.1;
            colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
            colors[i * 3 + 2] = 1.0;
        } else if (t < 0.8) {
            // Blue
            colors[i * 3] = 0.4 + Math.random() * 0.2;
            colors[i * 3 + 1] = 0.5 + Math.random() * 0.2;
            colors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
        } else if (t < 0.9) {
            // Warm yellow
            colors[i * 3] = 1.0;
            colors[i * 3 + 1] = 0.85 + Math.random() * 0.15;
            colors[i * 3 + 2] = 0.4 + Math.random() * 0.3;
        } else {
            // Red giant
            colors[i * 3] = 0.9 + Math.random() * 0.1;
            colors[i * 3 + 1] = 0.3 + Math.random() * 0.2;
            colors[i * 3 + 2] = 0.2 + Math.random() * 0.1;
        }

        sizes[i] = 0.2 + Math.random() * 0.6;
    }

    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({
        size: 0.4, vertexColors: true, opacity: 0.8, transparent: true
    })));

    // Faint nebula glow blobs
    var nebColors = [0x331155, 0x112244, 0x220033, 0x0a1133];
    for (var n = 0; n < 5; n++) {
        var nebGeo = new THREE.SphereGeometry(5 + Math.random() * 8, 12, 12);
        var nebMat = new THREE.MeshBasicMaterial({
            color: nebColors[n % nebColors.length],
            transparent: true,
            opacity: 0.15 + Math.random() * 0.1
        });
        var neb = new THREE.Mesh(nebGeo, nebMat);
        neb.position.set(
            (Math.random() - 0.5) * 80,
            -20 - Math.random() * 30,
            (Math.random() - 0.5) * 80
        );
        scene.add(neb);
    }
}

// ========== BACKGROUND EFFECTS ==========

function spawnBgEffect() {
    var roll = Math.random();

    if (roll < 0.35) {
        spawnShootingStar();
    } else if (roll < 0.55) {
        spawnSatellite();
    } else if (roll < 0.70) {
        spawnSupernova();
    } else if (roll < 0.85) {
        spawnAlien();
    } else {
        spawnAbsurdThing();
    }
}

function spawnShootingStar() {
    var geo = new THREE.BufferGeometry();
    var len = 2 + Math.random() * 3;
    var dx = (Math.random() - 0.5) * 0.8;
    var dy = -0.3 - Math.random() * 0.4;
    var dz = (Math.random() - 0.5) * 0.8;
    var mag = Math.sqrt(dx * dx + dy * dy + dz * dz);
    dx /= mag; dy /= mag; dz /= mag;

    var verts = new Float32Array([0, 0, 0, -dx * len, -dy * len, -dz * len]);
    geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));

    var mat = new THREE.LineBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0.9
    });
    var line = new THREE.Line(geo, mat);

    var sx = (Math.random() - 0.5) * 80;
    var sy = -12 - Math.random() * 20;
    var sz = (Math.random() - 0.5) * 80;
    line.position.set(sx, sy, sz);

    var speed = 0.6 + Math.random() * 0.8;
    scene.add(line);
    bgEffects.push({
        obj: line, type: 'shootingStar', life: 1,
        vx: dx * speed, vy: dy * speed, vz: dz * speed, decay: 0.012 + Math.random() * 0.008
    });
}

function spawnSatellite() {
    var group = new THREE.Group();

    // Body
    var body = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.15, 0.3),
        new THREE.MeshBasicMaterial({ color: 0xaaaaaa })
    );
    group.add(body);

    // Solar panels
    var panelMat = new THREE.MeshBasicMaterial({ color: 0x2244aa });
    var lp = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.02, 0.25), panelMat);
    lp.position.x = -0.4;
    group.add(lp);
    var rp = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.02, 0.25), panelMat);
    rp.position.x = 0.4;
    group.add(rp);

    // Blinking light
    var light = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 6, 6),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    light.position.y = 0.1;
    group.add(light);

    var sx = (Math.random() - 0.5) * 60;
    var sy = -15 - Math.random() * 15;
    var sz = (Math.random() - 0.5) * 60;
    group.position.set(sx, sy, sz);

    var angle = Math.random() * Math.PI * 2;
    var speed = 0.03 + Math.random() * 0.03;
    scene.add(group);
    bgEffects.push({
        obj: group, type: 'satellite', life: 1,
        vx: Math.cos(angle) * speed, vy: 0, vz: Math.sin(angle) * speed,
        decay: 0.001, blink: light
    });
}

function spawnSupernova() {
    var geo = new THREE.SphereGeometry(0.1, 12, 12);
    var mat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(Math.random() * 0.15, 1, 0.7),
        transparent: true, opacity: 1
    });
    var sphere = new THREE.Mesh(geo, mat);

    sphere.position.set(
        (Math.random() - 0.5) * 70,
        -15 - Math.random() * 25,
        (Math.random() - 0.5) * 70
    );
    scene.add(sphere);
    bgEffects.push({
        obj: sphere, type: 'supernova', life: 1,
        decay: 0.008, scale: 0.1, maxScale: 3 + Math.random() * 4
    });
}

function spawnAlien() {
    var group = new THREE.Group();

    // Saucer body
    var saucerMat = new THREE.MeshBasicMaterial({ color: 0x66ff66, transparent: true, opacity: 0.8 });
    var disc = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16), saucerMat);
    group.add(disc);

    // Dome
    var dome = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xaaffaa, transparent: true, opacity: 0.5 })
    );
    dome.position.y = 0.05;
    group.add(dome);

    // Beam
    var beamGeo = new THREE.CylinderGeometry(0.05, 0.3, 1.5, 8, 1, true);
    var beam = new THREE.Mesh(beamGeo, new THREE.MeshBasicMaterial({
        color: 0x44ff44, transparent: true, opacity: 0.25
    }));
    beam.position.y = -0.8;
    group.add(beam);

    // Blinking lights around rim
    for (var i = 0; i < 6; i++) {
        var a = (i / 6) * Math.PI * 2;
        var bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 6, 6),
            new THREE.MeshBasicMaterial({ color: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff][i] })
        );
        bulb.position.set(Math.cos(a) * 0.55, 0, Math.sin(a) * 0.55);
        group.add(bulb);
    }

    var sx = (Math.random() > 0.5 ? 1 : -1) * (40 + Math.random() * 20);
    var sy = -12 - Math.random() * 15;
    var sz = (Math.random() - 0.5) * 50;
    group.position.set(sx, sy, sz);

    var speed = 0.08 + Math.random() * 0.1;
    var dir = sx > 0 ? -1 : 1;
    scene.add(group);
    bgEffects.push({
        obj: group, type: 'alien', life: 1,
        vx: dir * speed, vy: Math.sin(Math.random()) * 0.01, vz: (Math.random() - 0.5) * 0.03,
        decay: 0.0015, wobble: 0
    });
}

function spawnAbsurdThing() {
    var group = new THREE.Group();
    var kind = Math.floor(Math.random() * 5);

    if (kind === 0) {
        // Rubber duck
        var duckBody = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 10, 10),
            new THREE.MeshBasicMaterial({ color: 0xffdd00 })
        );
        group.add(duckBody);
        var duckHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffdd00 })
        );
        duckHead.position.set(0.2, 0.2, 0);
        group.add(duckHead);
        var beak = new THREE.Mesh(
            new THREE.ConeGeometry(0.06, 0.15, 6),
            new THREE.MeshBasicMaterial({ color: 0xff8800 })
        );
        beak.rotation.z = -Math.PI / 2;
        beak.position.set(0.38, 0.2, 0);
        group.add(beak);
    } else if (kind === 1) {
        // Giant pizza slice
        var pizzaGeo = new THREE.CylinderGeometry(0, 0.5, 0.06, 3);
        var pizzaMat = new THREE.MeshBasicMaterial({ color: 0xdaa520 });
        group.add(new THREE.Mesh(pizzaGeo, pizzaMat));
        // Pepperoni
        for (var p = 0; p < 3; p++) {
            var pep = new THREE.Mesh(
                new THREE.SphereGeometry(0.06, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xcc2200 })
            );
            pep.position.set((Math.random() - 0.5) * 0.2, 0.04, (Math.random() - 0.3) * 0.2);
            group.add(pep);
        }
    } else if (kind === 2) {
        // Toilet
        var bowl = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.15, 0.3, 12),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        group.add(bowl);
        var tank = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.25, 0.12),
            new THREE.MeshBasicMaterial({ color: 0xeeeeee })
        );
        tank.position.set(0, 0.1, -0.15);
        group.add(tank);
        var lid = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 0.03, 12),
            new THREE.MeshBasicMaterial({ color: 0xdddddd })
        );
        lid.position.y = 0.16;
        lid.rotation.x = -0.5;
        group.add(lid);
    } else if (kind === 3) {
        // Giant eyeball
        var eyeball = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffeedd })
        );
        group.add(eyeball);
        var iris = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0x2266aa })
        );
        iris.position.z = 0.28;
        group.add(iris);
        var pupil = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        pupil.position.z = 0.34;
        group.add(pupil);
    } else {
        // Banana
        var bananaMat = new THREE.MeshBasicMaterial({ color: 0xffe135 });
        var seg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8), bananaMat);
        seg1.rotation.z = 0.2;
        group.add(seg1);
        var seg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.3, 8), bananaMat);
        seg2.position.set(0.05, 0.28, 0);
        seg2.rotation.z = -0.2;
        group.add(seg2);
        var tip = new THREE.Mesh(
            new THREE.ConeGeometry(0.05, 0.1, 6),
            new THREE.MeshBasicMaterial({ color: 0x6b4226 })
        );
        tip.position.set(0.02, 0.45, 0);
        group.add(tip);
    }

    var sx = (Math.random() - 0.5) * 70;
    var sy = -10 - Math.random() * 25;
    var sz = (Math.random() - 0.5) * 70;
    group.position.set(sx, sy, sz);
    group.scale.setScalar(0.8 + Math.random() * 0.5);

    var speed = 0.02 + Math.random() * 0.04;
    var angle = Math.random() * Math.PI * 2;
    scene.add(group);
    bgEffects.push({
        obj: group, type: 'absurd', life: 1,
        vx: Math.cos(angle) * speed, vy: (Math.random() - 0.5) * 0.01, vz: Math.sin(angle) * speed,
        decay: 0.0012, spin: (Math.random() - 0.5) * 0.05
    });
}

// ========== UPDATE BACKGROUND ==========

var lastBgSpawnTime = 0;

function updateBackground() {
    var now = performance.now();

    // Spawn new effects periodically
    if (now - lastBgSpawnTime > 600 + Math.random() * 1200) {
        lastBgSpawnTime = now;
        spawnBgEffect();
    }

    // Cap active effects
    while (bgEffects.length > 25) {
        var old = bgEffects.shift();
        scene.remove(old.obj);
    }

    for (var i = bgEffects.length - 1; i >= 0; i--) {
        var e = bgEffects[i];
        e.life -= e.decay;

        if (e.life <= 0) {
            scene.remove(e.obj);
            bgEffects.splice(i, 1);
            continue;
        }

        // Move
        e.obj.position.x += e.vx || 0;
        e.obj.position.y += e.vy || 0;
        e.obj.position.z += e.vz || 0;

        if (e.type === 'shootingStar') {
            e.obj.material.opacity = e.life;
        } else if (e.type === 'satellite') {
            // Blink light
            if (e.blink) {
                e.blink.visible = Math.sin(now * 0.008) > 0;
            }
            e.obj.rotation.y += 0.005;
        } else if (e.type === 'supernova') {
            e.scale = Math.min(e.scale + 0.06, e.maxScale);
            e.obj.scale.setScalar(e.scale);
            e.obj.material.opacity = e.life * 0.8;
        } else if (e.type === 'alien') {
            e.wobble += 0.05;
            e.obj.position.y += Math.sin(e.wobble) * 0.02;
            e.obj.rotation.y += 0.02;
        } else if (e.type === 'absurd') {
            e.obj.rotation.x += e.spin || 0;
            e.obj.rotation.y += (e.spin || 0) * 0.7;
        }
    }
}

// ========== PLAYER BOX ==========

function createPlayerBox() {
    const boxGeo = new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE);
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#c4a574';
    ctx.fillRect(0, 0, 128, 128);
    ctx.strokeStyle = '#a08050';
    ctx.lineWidth = 3;
    ctx.strokeRect(2, 2, 124, 124);
    ctx.beginPath(); ctx.moveTo(0, 64); ctx.lineTo(128, 64); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(64, 0); ctx.lineTo(64, 128); ctx.stroke();

    const boxMat = new THREE.MeshStandardMaterial({
        map: new THREE.CanvasTexture(canvas), roughness: 0.8
    });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set(0, BOX_SIZE / 2 + 0.01, 0);
    box.castShadow = true;
    scene.add(box);
    gameState.playerBox = box;
}

function onWindowResize() {
    const a = window.innerWidth / window.innerHeight;
    camera.aspect = a;
    camera.fov = a < 1 ? 75 : 60;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


// ========== input.js ==========
/**
 * Lablix - Input Handling (Gyroscope)
 */

function isMobileDevice() {
    const ua = navigator.userAgent || '';
    const mobile = /android|iphone|ipad|ipod|mobile|tablet/i.test(ua.toLowerCase());
    const touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    return mobile || (touch && window.innerWidth < 1024);
}

async function requestGyroPermission() {
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            return (await DeviceOrientationEvent.requestPermission()) === 'granted';
        } catch (e) { return false; }
    }
    return typeof DeviceOrientationEvent !== 'undefined';
}

function startGyroscope() {
    gameState.gyroReceived = false;
    window.addEventListener('deviceorientation', onDeviceOrientation, true);

    setTimeout(() => {
        if (!gameState.gyroReceived) {
            const el = document.getElementById('gyro-check');
            var notDetected = typeof getText === 'function' ? getText('ui', 'gyroNotDetected') : 'Not detected';
            if (el) { el.textContent = notDetected; el.className = 'error'; }
        }
    }, 2000);
}

function onDeviceOrientation(e) {
    if (e.beta === null && e.gamma === null) return;
    gameState.gyro.beta = e.beta || 0;
    gameState.gyro.gamma = e.gamma || 0;
    gameState.gyroReceived = true;

    if (gameState.currentScreen !== 'calibration') return;

    var beta = gameState.gyro.beta;
    var gamma = gameState.gyro.gamma;
    var isFlat = Math.abs(beta) < 5 && Math.abs(gamma) < 5;

    // Update gyro status text
    var el = document.getElementById('gyro-check');
    if (el) {
        var flatText = typeof getText === 'function' ? getText('ui', 'gyroCheckFlat') : 'Perfect! Phone is level';
        el.textContent = isFlat ? flatText : 'Î²:' + beta.toFixed(0) + 'Â° Î³:' + gamma.toFixed(0) + 'Â°';
        el.className = isFlat ? 'working' : '';
    }

    // Move tilt dot (clamp to circle bounds)
    var dot = document.getElementById('tilt-dot');
    if (dot) {
        var maxOffset = 90; // half of 200px container minus dot radius
        var dx = Math.max(-1, Math.min(1, gamma / 30)) * maxOffset;
        var dy = Math.max(-1, Math.min(1, beta / 30)) * maxOffset;
        dot.style.left = 'calc(50% + ' + dx + 'px)';
        dot.style.top = 'calc(50% + ' + dy + 'px)';
        dot.className = isFlat ? 'tilt-dot centered' : 'tilt-dot';
    }

    // Tilt the phone icon to mirror actual tilt
    var icon = document.getElementById('phone-icon');
    if (icon) {
        icon.style.transform = 'rotate(' + Math.max(-20, Math.min(20, gamma)) + 'deg)';
    }

    // Background color and title
    var screen = document.getElementById('calibration-screen');
    var title = document.getElementById('calibration-title');
    var hint = document.getElementById('tilt-hint');
    var msg = document.getElementById('calibration-msg');

    if (screen) {
        if (isFlat) {
            screen.classList.add('level-ok');
        } else {
            screen.classList.remove('level-ok');
        }
    }

    if (title) {
        var readyText = typeof getText === 'function' ? getText('ui', 'ready') : 'READY!';
        var holdText = typeof getText === 'function' ? getText('ui', 'holdFlat') : 'HOLD FLAT';
        title.textContent = isFlat ? readyText : holdText;
        title.style.color = isFlat ? '#4ade80' : '#fff';
    }

    if (msg) {
        var msgFlat = typeof getText === 'function' ? getText('ui', 'calibrationMsgFlat') : 'Great! This position is your neutral balance point';
        var msgTilt = typeof getText === 'function' ? getText('ui', 'calibrationMsgTilt') : 'Place your phone flat on a table or hold it level';
        msg.textContent = isFlat ? msgFlat : msgTilt;
    }

    if (hint) {
        var hintFlat = typeof getText === 'function' ? getText('ui', 'calibrationHintFlat') : 'Tap START NOW to begin!';
        var hintTilt = typeof getText === 'function' ? getText('ui', 'calibrationHintTilt') : 'Tilt gently until the dot is centered';
        hint.textContent = isFlat ? hintFlat : hintTilt;
    }

    // Show/hide start button
    var btn = document.getElementById('calibrate-button');
    if (btn) {
        if (isFlat) {
            btn.classList.add('calibrate-visible');
            btn.classList.remove('calibrate-hidden');
        } else {
            btn.classList.remove('calibrate-visible');
            btn.classList.add('calibrate-hidden');
        }
    }
}

async function requestWakeLock() {
    // Release any existing lock first
    if (wakeLock) {
        try { await wakeLock.release(); } catch (e) {}
        wakeLock = null;
    }

    // Try Wake Lock API
    if ('wakeLock' in navigator) {
        try {
            wakeLock = await navigator.wakeLock.request('screen');
            console.log('Wake lock acquired');

            // Re-acquire on visibility change
            wakeLock.addEventListener('release', () => {
                console.log('Wake lock released');
                // Try to re-acquire if still playing
                if (gameState.isPlaying && document.visibilityState === 'visible') {
                    requestWakeLock();
                }
            });
            return true;
        } catch (e) {
            console.log('Wake lock failed:', e.message);
        }
    }

    // Fallback: create invisible video to keep screen on
    if (!window._noSleepVideo) {
        const video = document.createElement('video');
        video.setAttribute('playsinline', '');
        video.setAttribute('muted', '');
        video.setAttribute('loop', '');
        video.style.position = 'fixed';
        video.style.top = '-1px';
        video.style.left = '-1px';
        video.style.width = '1px';
        video.style.height = '1px';
        video.style.opacity = '0.01';

        // Tiny webm video (transparent 1x1 pixel, 1 second)
        video.src = 'data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAB5BFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEuTbuMU6uEHFO7a1OsggI+7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEMq17GDD0JATYCMTGF2ZjU4LjI5LjEwMFdBjUxhdmY1OC4yOS4xMDBzpJAAAAAAAAAWVK5rAQAAAAAAACvXsYMPQkBNgIxMYXZmNTguMjkuMTAwV0markup+IGxhdmY1OC4yOS4xMDAAAAAAAA==';

        document.body.appendChild(video);
        window._noSleepVideo = video;
    }

    try {
        await window._noSleepVideo.play();
        console.log('NoSleep video fallback active');
        return true;
    } catch (e) {
        console.log('NoSleep fallback failed:', e.message);
    }

    return false;
}

async function releaseWakeLock() {
    if (wakeLock) {
        try { await wakeLock.release(); } catch (e) {}
        wakeLock = null;
    }

    if (window._noSleepVideo) {
        window._noSleepVideo.pause();
    }
}

async function enterFullscreen() {
    try {
        const elem = document.documentElement;
        if (elem.requestFullscreen) await elem.requestFullscreen();
        else if (elem.webkitRequestFullscreen) await elem.webkitRequestFullscreen();
    } catch (e) {}
}

function exitFullscreen() {
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
}

function lockOrientation() {
    if (screen.orientation?.lock) screen.orientation.lock('portrait').catch(() => {});
}

function unlockOrientation() {
    if (screen.orientation?.unlock) screen.orientation.unlock();
}


// ========== audio.js ==========
/**
 * Lablix - FX Audio System
 */

let fxStep, fxWosh, fxHit, fxCoin, fxFall;
let fxInitialized = false;
let stepTimerId = null;

function initFxAudio() {
    if (fxInitialized) return;

    fxStep = new Audio('audio/fx/step.mp3');
    fxWosh = new Audio('audio/fx/wosh.mp3');
    fxHit = new Audio('audio/fx/hit.mp3');
    fxCoin = new Audio('audio/fx/coin.mp3');
    fxFall = new Audio('audio/fx/fall.mp3');

    // Unlock all during user gesture
    [fxStep, fxWosh, fxHit, fxCoin, fxFall].forEach(function(a) {
        a.play().then(function() { a.pause(); a.currentTime = 0; }).catch(function(){});
    });

    fxInitialized = true;
}

function playWosh() {
    if (!fxWosh) return;
    var s = fxWosh.cloneNode();
    s.volume = 0.6;
    s.play().catch(function(){});
}

function playHit() {
    if (!fxHit) return;
    var s = fxHit.cloneNode();
    s.volume = 0.7;
    s.play().catch(function(){});
}

function playCoin() {
    if (!fxCoin) return;
    var s = fxCoin.cloneNode();
    s.volume = 0.5;
    s.play().catch(function(){});
}

function playFall() {
    if (!fxFall) return;
    var s = fxFall.cloneNode();
    s.volume = 0.45;
    s.play().catch(function(){});
}

function startStepLoop() {
    stopStepLoop();
    stepTick();
}

function stopStepLoop() {
    if (stepTimerId) {
        clearTimeout(stepTimerId);
        stepTimerId = null;
    }
}

function stepTick() {
    if (!gameState.isPlaying || gameState.isFalling || !fxStep) {
        stepTimerId = setTimeout(stepTick, 300);
        return;
    }

    var speed = Math.sqrt(
        gameState.velocity.x * gameState.velocity.x +
        gameState.velocity.z * gameState.velocity.z
    );

    // Only play if actually rolling (not gyro noise)
    if (speed > 0.02) {
        var s = fxStep.cloneNode();
        s.volume = 0.5;
        s.play().catch(function(){});

        // Faster = shorter gap (500ms slow, 100ms fast)
        var ratio = Math.min(1, speed / MAX_VELOCITY);
        stepTimerId = setTimeout(stepTick, Math.round(500 - ratio * 400));
    } else {
        // Not rolling â€” check again soon but don't play
        stepTimerId = setTimeout(stepTick, 200);
    }
}

function updateStepSound() {}

function stopAllFx() {
    stopStepLoop();
}


// ========== physics.js ==========
/**
 * Lablix - Physics System
 */

function updatePhysics() {
    if (!gameState.playerBox || !gameState.isOnPlatform) return;

    // Tilt input
    const tiltBeta = gameState.gyro.beta - gameState.calibration.beta;
    const tiltGamma = gameState.gyro.gamma - gameState.calibration.gamma;
    gameState.tilt.x = Math.max(-1, Math.min(1, tiltGamma / 60));
    gameState.tilt.z = Math.max(-1, Math.min(1, tiltBeta / 60));

    // Apply acceleration
    gameState.velocity.x += gameState.tilt.x * ACCELERATION;
    gameState.velocity.z += gameState.tilt.z * ACCELERATION;

    // Apply friction
    gameState.velocity.x *= FRICTION;
    gameState.velocity.z *= FRICTION;

    // Clamp velocity
    const speed = Math.sqrt(gameState.velocity.x ** 2 + gameState.velocity.z ** 2);
    if (speed > MAX_VELOCITY) {
        gameState.velocity.x *= MAX_VELOCITY / speed;
        gameState.velocity.z *= MAX_VELOCITY / speed;
    }

    // Stop tiny movements
    if (Math.abs(gameState.velocity.x) < 0.0001) gameState.velocity.x = 0;
    if (Math.abs(gameState.velocity.z) < 0.0001) gameState.velocity.z = 0;

    // Update position
    gameState.playerBox.position.x += gameState.velocity.x;
    gameState.playerBox.position.z += gameState.velocity.z;

    // Rolling with quaternions
    updateBoxRotation();

    // Edge check
    checkEdges();
}

function updateBoxRotation() {
    const vx = gameState.velocity.x, vz = gameState.velocity.z;
    const spd = Math.sqrt(vx * vx + vz * vz);
    if (spd > 0.0001) {
        const angle = spd / (BOX_SIZE / 2);
        rotationAxis.set(vz, 0, -vx).normalize();
        tempQuaternion.setFromAxisAngle(rotationAxis, angle);
        gameState.playerBox.quaternion.premultiply(tempQuaternion);
    }
}

function checkEdges() {
    const hw = PLATFORM_WIDTH / 2, hd = PLATFORM_DEPTH / 2;
    const px = gameState.playerBox.position.x, pz = gameState.playerBox.position.z;
    if (px < -hw || px > hw || pz < -hd || pz > hd) {
        gameState.isOnPlatform = false;
        onFallOff();
    }
}

function onFallOff() {
    stopAllFx();
    playFall();
    gameState.isFalling = true;
    gameState.fallVelocity = 0;
    gameState.lives = 0;
    gameState.fallRotation.x = (Math.random() - 0.5) * 0.1;
    gameState.fallRotation.z = (Math.random() - 0.5) * 0.1;

    // Trigger fall taunt and clear projectiles
    triggerFallTaunt();
    clearAllProjectiles();

    // Show game over with translated message
    setTimeout(() => {
        const msg = typeof getDeathMessage === 'function' ? getDeathMessage('fall') : 'You Fell Off!';
        showGameOver(msg);
    }, 2500);
}

function updateFalling() {
    if (!gameState.isFalling || !gameState.playerBox) return;

    gameState.fallVelocity += FALL_GRAVITY;
    gameState.playerBox.position.y -= gameState.fallVelocity;
    gameState.playerBox.position.x += gameState.velocity.x * 0.5;
    gameState.playerBox.position.z += gameState.velocity.z * 0.5;

    // Tumble
    const axis = new THREE.Vector3(gameState.fallRotation.x, 0, gameState.fallRotation.z);
    if (axis.length() > 0) {
        tempQuaternion.setFromAxisAngle(axis.normalize(), 0.1);
        gameState.playerBox.quaternion.premultiply(tempQuaternion);
    }

    // Camera follows
    if (gameState.playerBox.position.y > -20) {
        camera.position.y = Math.max(10, 18 + gameState.playerBox.position.y * 0.3);
        camera.lookAt(
            gameState.playerBox.position.x * 0.3,
            Math.max(-5, gameState.playerBox.position.y * 0.5),
            gameState.playerBox.position.z * 0.3
        );
    }
}


// ========== coin.js ==========
/**
 * Lablix - Coin System
 */

let currentCoin = null;
const COIN_RADIUS = 0.4;
const COIN_HEIGHT = 0.1;
const COIN_MARGIN = 1.5;  // Min distance from edges
const MIN_DISTANCE_FROM_BOX = 2;  // Min spawn distance from player

function createCoin() {
    if (currentCoin) {
        scene.remove(currentCoin);
    }

    // Create coin geometry (cylinder)
    const geometry = new THREE.CylinderGeometry(COIN_RADIUS, COIN_RADIUS, COIN_HEIGHT, 32);

    // Gold material with glow
    const material = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0xffa500,
        emissiveIntensity: 0.3
    });

    currentCoin = new THREE.Mesh(geometry, material);
    currentCoin.rotation.x = Math.PI / 2;  // Lay flat, facing up
    currentCoin.castShadow = true;

    // Spawn at random safe position
    spawnCoinAtRandomPosition();

    scene.add(currentCoin);
}

function spawnCoinAtRandomPosition() {
    if (!currentCoin) return;

    const safeWidth = PLATFORM_WIDTH / 2 - COIN_MARGIN;
    const safeDepth = PLATFORM_DEPTH / 2 - COIN_MARGIN;

    let attempts = 0;
    let x, z;

    // Find position not too close to player
    do {
        x = (Math.random() * 2 - 1) * safeWidth;
        z = (Math.random() * 2 - 1) * safeDepth;
        attempts++;
    } while (
        attempts < 20 &&
        gameState.playerBox &&
        distanceToBox(x, z) < MIN_DISTANCE_FROM_BOX
    );

    currentCoin.position.set(x, COIN_RADIUS + 0.05, z);
}

function distanceToBox(x, z) {
    if (!gameState.playerBox) return Infinity;
    const dx = x - gameState.playerBox.position.x;
    const dz = z - gameState.playerBox.position.z;
    return Math.sqrt(dx * dx + dz * dz);
}

function updateCoin() {
    if (!currentCoin || !gameState.playerBox || gameState.isFalling) return;

    // Rotate coin
    currentCoin.rotation.z += 0.03;

    // Hover animation
    currentCoin.position.y = COIN_RADIUS + 0.05 + Math.sin(performance.now() * 0.005) * 0.15;

    // Check collision with player
    const dx = currentCoin.position.x - gameState.playerBox.position.x;
    const dz = currentCoin.position.z - gameState.playerBox.position.z;
    const distance = Math.sqrt(dx * dx + dz * dz);

    if (distance < (BOX_SIZE / 2 + COIN_RADIUS)) {
        collectCoin();
    }
}

function collectCoin() {
    playCoin();
    gameState.score++;
    updateUI();

    // Spawn particle effect
    createCoinParticles(currentCoin.position.x, currentCoin.position.z);

    // Spawn new coin
    spawnCoinAtRandomPosition();
}

function createCoinParticles(x, z) {
    const particleCount = 12;
    const particles = [];

    for (let i = 0; i < particleCount; i++) {
        const geometry = new THREE.SphereGeometry(0.08, 8, 8);
        const material = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            transparent: true,
            opacity: 1
        });
        const particle = new THREE.Mesh(geometry, material);

        const angle = (i / particleCount) * Math.PI * 2;
        particle.position.set(x, 0.5, z);
        particle.userData.velocity = {
            x: Math.cos(angle) * 0.1,
            y: 0.15 + Math.random() * 0.1,
            z: Math.sin(angle) * 0.1
        };
        particle.userData.life = 1;

        scene.add(particle);
        particles.push(particle);
    }

    // Animate particles
    function animateParticles() {
        let alive = false;
        particles.forEach(p => {
            if (p.userData.life > 0) {
                alive = true;
                p.userData.life -= 0.03;
                p.userData.velocity.y -= 0.008;  // Gravity
                p.position.x += p.userData.velocity.x;
                p.position.y += p.userData.velocity.y;
                p.position.z += p.userData.velocity.z;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
            }
        });

        if (alive) {
            requestAnimationFrame(animateParticles);
        } else {
            particles.forEach(p => scene.remove(p));
        }
    }
    animateParticles();
}

function removeCoin() {
    if (currentCoin) {
        scene.remove(currentCoin);
        currentCoin = null;
    }
}


// ========== difficulty.js ==========
/**
 * Lablix - Progressive Difficulty System (Phase 11)
 * With multilingual support
 */

// Difficulty tier configuration
const DIFFICULTY_CONFIG = {
    1: {
        nameKey: 'difficultyEasy',
        color: '#4ade80',
        fireRate: 5000,
        accuracy: 0.3,
        enemySpeed: 0.02,
        projectileSpeed: 0.10,
        tauntChance: 0.004
    },
    2: {
        nameKey: 'difficultyMedium',
        color: '#fbbf24',
        fireRate: 3000,
        accuracy: 0.5,
        enemySpeed: 0.03,
        projectileSpeed: 0.12,
        tauntChance: 0.005
    },
    3: {
        nameKey: 'difficultyHard',
        color: '#f97316',
        fireRate: 2000,
        accuracy: 0.7,
        enemySpeed: 0.04,
        projectileSpeed: 0.14,
        tauntChance: 0.006
    },
    4: {
        nameKey: 'difficultyBrutal',
        color: '#ef4444',
        fireRate: 1500,
        accuracy: 0.9,
        enemySpeed: 0.05,
        projectileSpeed: 0.16,
        tauntChance: 0.008
    }
};

// Score thresholds for each tier
const TIER_THRESHOLDS = [0, 6, 16, 31]; // Tier 1: 0-5, Tier 2: 6-15, Tier 3: 16-30, Tier 4: 31+

let lastDisplayedTier = 0;
let difficultyIndicator = null;

function calculateDifficultyTier() {
    const score = gameState.score;
    if (score >= TIER_THRESHOLDS[3]) return 4;
    if (score >= TIER_THRESHOLDS[2]) return 3;
    if (score >= TIER_THRESHOLDS[1]) return 2;
    return 1;
}

function getDifficultyConfig() {
    const tier = calculateDifficultyTier();
    return DIFFICULTY_CONFIG[tier];
}

function getDifficultyName(tier) {
    const config = DIFFICULTY_CONFIG[tier];
    if (typeof getText === 'function') {
        return getText('ui', config.nameKey);
    }
    // Fallback
    const fallbacks = { 1: 'EASY', 2: 'MEDIUM', 3: 'HARD', 4: 'BRUTAL' };
    return fallbacks[tier];
}

function initDifficultyUI() {
    // Create difficulty indicator if it doesn't exist
    if (!difficultyIndicator) {
        difficultyIndicator = document.createElement('div');
        difficultyIndicator.id = 'difficulty-indicator';
    }

    const container = document.getElementById('game-container');
    if (container && !document.getElementById('difficulty-indicator')) {
        container.appendChild(difficultyIndicator);
    }

    updateDifficultyUI();
}

function updateDifficultyUI() {
    const tier = calculateDifficultyTier();
    const config = DIFFICULTY_CONFIG[tier];

    if (!difficultyIndicator) return;

    const tierLabel = typeof getText === 'function' ? getText('ui', 'tierLabel') : 'TIER';
    const tierName = getDifficultyName(tier);

    // Update tier display
    difficultyIndicator.className = `tier-${tier}`;
    difficultyIndicator.innerHTML = `<span class="tier-label">${tierLabel} ${tier}</span><span class="tier-name">${tierName}</span>`;
    difficultyIndicator.style.borderColor = config.color;
    difficultyIndicator.style.color = config.color;

    // Check if tier increased
    if (tier > lastDisplayedTier && lastDisplayedTier > 0) {
        onDifficultyIncrease(tier, config);
    }

    lastDisplayedTier = tier;
    gameState.difficultyTier = tier;
}

let gamePausedForTierUp = false;
let tierUpShootCooldown = 0;

function onDifficultyIncrease(tier, config) {
    // Pause the game during tier-up
    gamePausedForTierUp = true;

    // Clear all projectiles so no shoe hits the player when the game resumes
    if (typeof clearAllProjectiles === 'function') {
        clearAllProjectiles();
    }

    // Reset player velocity so they start stable
    gameState.velocity.x = 0;
    gameState.velocity.z = 0;

    // Move enemy to the far corner opposite the player for breathing room
    if (gameState.enemy && gameState.playerBox) {
        const hw = PLATFORM_WIDTH / 2 - ENEMY_SAFE_MARGIN;
        const hd = PLATFORM_DEPTH / 2 - ENEMY_SAFE_MARGIN;
        const px = gameState.playerBox.position.x;
        const pz = gameState.playerBox.position.z;
        const farX = px >= 0 ? -hw : hw;
        const farZ = pz >= 0 ? -hd : hd;
        gameState.enemy.position.x = farX;
        gameState.enemy.position.z = farZ;
        gameState.enemy.userData.targetX = farX;
        gameState.enemy.userData.targetZ = farZ;
    }

    // Show tier up notification
    showTierUpNotification(tier, config);

    // Visual feedback - flash the indicator
    if (difficultyIndicator) {
        difficultyIndicator.classList.add('tier-up');
        setTimeout(function() {
            difficultyIndicator.classList.remove('tier-up');
        }, 1000);
    }

    // Wait for current taunt to finish, then play tier-up taunt, then resume
    waitForTauntThenPlayTierUp(tier);
}

function waitForTauntThenPlayTierUp(tier) {
    if (tauntSpeaking) {
        setTimeout(function() { waitForTauntThenPlayTierUp(tier); }, 100);
        return;
    }

    // Current taunt done â€” now play the difficulty taunt
    var taunt = typeof getDifficultyTaunt === 'function' ? getDifficultyTaunt(tier) : null;
    if (taunt) {
        showTaunt(taunt, true);
        waitForTierTauntThenResume();
    } else {
        gamePausedForTierUp = false;
        tierUpShootCooldown = performance.now() + 1000;
    }
}

function waitForTierTauntThenResume() {
    if (tauntSpeaking) {
        setTimeout(waitForTierTauntThenResume, 100);
        return;
    }
    // Tier-up taunt finished â€” hide notification and resume game
    hideTierUpNotification();
    tierUpShootCooldown = performance.now() + 1000;
    gamePausedForTierUp = false;
}

function canEnemyShoot() {
    return performance.now() > tierUpShootCooldown;
}

function isGamePausedForTierUp() {
    return gamePausedForTierUp;
}

var activeTierNotification = null;

function showTierUpNotification(tier, config) {
    // Remove any existing notification
    hideTierUpNotification();

    const notification = document.createElement('div');
    notification.className = 'tier-up-notification';
    notification.style.color = config.color;

    const increasedText = typeof getText === 'function' ? getText('ui', 'difficultyIncreased') : 'DIFFICULTY INCREASED';
    const tierName = getDifficultyName(tier);

    notification.innerHTML = `
        <div class="tier-up-icon">âš ï¸</div>
        <div class="tier-up-text">${increasedText}</div>
        <div class="tier-up-name">${tierName}</div>
    `;

    const container = document.getElementById('game-container');
    if (container) {
        container.appendChild(notification);
        activeTierNotification = notification;

        // Animate in
        requestAnimationFrame(() => {
            notification.classList.add('visible');
        });
    }
}

function hideTierUpNotification() {
    if (activeTierNotification) {
        activeTierNotification.classList.remove('visible');
        var el = activeTierNotification;
        setTimeout(function() { el.remove(); }, 500);
        activeTierNotification = null;
    }
}

// triggerDifficultyTaunt is now handled by waitForTauntThenPlayTierUp

function getEnemySpeedForTier() {
    const config = getDifficultyConfig();
    return config.enemySpeed;
}

function getProjectileSpeedForTier() {
    const config = getDifficultyConfig();
    return config.projectileSpeed;
}

function getFireRateForTier() {
    const config = getDifficultyConfig();
    return config.fireRate;
}

function getAccuracyForTier() {
    const config = getDifficultyConfig();
    return config.accuracy;
}

function getTauntChanceForTier() {
    const config = getDifficultyConfig();
    return config.tauntChance;
}

function resetDifficulty() {
    lastDisplayedTier = 0;
    gameState.difficultyTier = 1;
    gamePausedForTierUp = false;
    updateDifficultyUI();
}


// ========== enemy.js ==========
/**
 * Lablix - Enemy Character System (Phase 7)
 * Angry woman who throws shoes at the player
 */

// Enemy constants
const ENEMY_SIZE = 1.2; // Bigger character
const ENEMY_BASE_SPEED = 0.025;
const ENEMY_SAFE_MARGIN = 1.8;
const ENEMY_MIN_PLAYER_DISTANCE = 4.5;

function createEnemy() {
    const enemy = new THREE.Group();

    // === BODY ===
    // Torso (dress shape - wider at bottom)
    const torsoGeo = new THREE.CylinderGeometry(0.35, 0.55, 1.2, 8);
    const dressMat = new THREE.MeshStandardMaterial({
        color: 0x8b0000, // Dark red dress
        roughness: 0.7
    });
    const torso = new THREE.Mesh(torsoGeo, dressMat);
    torso.position.y = 0.6;
    torso.castShadow = true;
    enemy.add(torso);

    // Upper body
    const upperGeo = new THREE.CylinderGeometry(0.32, 0.35, 0.5, 8);
    const upper = new THREE.Mesh(upperGeo, dressMat);
    upper.position.y = 1.45;
    upper.castShadow = true;
    enemy.add(upper);

    // === HEAD ===
    const headGeo = new THREE.SphereGeometry(0.28, 16, 16);
    const skinMat = new THREE.MeshStandardMaterial({
        color: 0xdeb887, // Skin tone
        roughness: 0.8
    });
    const head = new THREE.Mesh(headGeo, skinMat);
    head.position.y = 2.0;
    head.castShadow = true;
    enemy.add(head);

    // Hair (angry bun style)
    const hairMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.9
    });
    const hairGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const hair = new THREE.Mesh(hairGeo, hairMat);
    hair.position.set(0, 2.05, -0.05);
    hair.scale.set(1, 0.9, 1);
    enemy.add(hair);

    // Hair bun
    const bunGeo = new THREE.SphereGeometry(0.15, 12, 12);
    const bun = new THREE.Mesh(bunGeo, hairMat);
    bun.position.set(0, 2.3, -0.1);
    enemy.add(bun);

    // === ANGRY FACE ===
    // Eyes (angry, slanted)
    const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.1, 2.02, 0.22);
    enemy.add(leftEye);

    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEye.position.set(0.1, 2.02, 0.22);
    enemy.add(rightEye);

    // Angry eyebrows
    const browGeo = new THREE.BoxGeometry(0.12, 0.025, 0.02);
    const browMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });

    const leftBrow = new THREE.Mesh(browGeo, browMat);
    leftBrow.position.set(-0.1, 2.1, 0.24);
    leftBrow.rotation.z = 0.3; // Angry slant
    enemy.add(leftBrow);

    const rightBrow = new THREE.Mesh(browGeo, browMat);
    rightBrow.position.set(0.1, 2.1, 0.24);
    rightBrow.rotation.z = -0.3; // Angry slant
    enemy.add(rightBrow);

    // Frowning mouth
    const mouthGeo = new THREE.TorusGeometry(0.06, 0.015, 8, 12, Math.PI);
    const mouthMat = new THREE.MeshBasicMaterial({ color: 0x8b0000 });
    const mouth = new THREE.Mesh(mouthGeo, mouthMat);
    mouth.position.set(0, 1.9, 0.24);
    mouth.rotation.x = Math.PI;
    mouth.rotation.z = Math.PI;
    enemy.add(mouth);

    // === ARMS ===
    const armGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 8);

    // Left arm (static)
    const leftArmGroup = new THREE.Group();
    const leftArm = new THREE.Mesh(armGeo, skinMat);
    leftArm.position.y = -0.25;
    leftArm.castShadow = true;
    leftArmGroup.add(leftArm);
    leftArmGroup.position.set(-0.45, 1.5, 0);
    leftArmGroup.rotation.z = 0.3;
    enemy.add(leftArmGroup);

    // Left hand
    const handGeo = new THREE.SphereGeometry(0.08, 8, 8);
    const leftHand = new THREE.Mesh(handGeo, skinMat);
    leftHand.position.y = -0.55;
    leftArmGroup.add(leftHand);

    // Right arm (throwing arm)
    const rightArmGroup = new THREE.Group();
    const rightArm = new THREE.Mesh(armGeo, skinMat);
    rightArm.position.y = -0.25;
    rightArm.castShadow = true;
    rightArmGroup.add(rightArm);
    rightArmGroup.position.set(0.45, 1.5, 0);
    rightArmGroup.rotation.z = -0.3;
    enemy.add(rightArmGroup);
    enemy.userData.rightArm = rightArmGroup;

    // Right hand (holds shoe)
    const rightHand = new THREE.Mesh(handGeo, skinMat);
    rightHand.position.y = -0.55;
    rightArmGroup.add(rightHand);
    enemy.userData.rightHand = rightHand;

    // Held shoe (visible during throw animation) - red high heel
    const heldShoeGroup = new THREE.Group();
    const heldShoeMat = new THREE.MeshStandardMaterial({
        color: 0xcc0033, // Red patent leather
        roughness: 0.3,
        metalness: 0.2
    });
    const heldSoleMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

    // Shoe body
    const heldShoeBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.07, 0.2),
        heldShoeMat
    );
    heldShoeBody.position.z = 0.05;
    heldShoeGroup.add(heldShoeBody);

    // Pointed toe
    const heldToe = new THREE.Mesh(
        new THREE.ConeGeometry(0.04, 0.1, 4),
        heldShoeMat
    );
    heldToe.rotation.x = Math.PI / 2;
    heldToe.rotation.y = Math.PI / 4;
    heldToe.position.z = 0.18;
    heldShoeGroup.add(heldToe);

    // Stiletto heel
    const heldHeel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.025, 0.12, 6),
        heldSoleMat
    );
    heldHeel.position.set(0, -0.06, -0.08);
    heldShoeGroup.add(heldHeel);

    // Heel back
    const heldHeelBack = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, 0.06),
        heldShoeMat
    );
    heldHeelBack.position.set(0, 0.02, -0.08);
    heldShoeGroup.add(heldHeelBack);

    heldShoeGroup.position.set(0, -0.7, 0.15);
    heldShoeGroup.rotation.x = 0.3;
    heldShoeGroup.visible = false;
    rightArmGroup.add(heldShoeGroup);
    enemy.userData.heldShoe = heldShoeGroup;

    // === LEGS ===
    const legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);

    const leftLeg = new THREE.Mesh(legGeo, skinMat);
    leftLeg.position.set(-0.2, -0.25, 0);
    leftLeg.castShadow = true;
    enemy.add(leftLeg);
    enemy.userData.leftLeg = leftLeg;

    const rightLeg = new THREE.Mesh(legGeo, skinMat);
    rightLeg.position.set(0.2, -0.25, 0);
    rightLeg.castShadow = true;
    enemy.add(rightLeg);
    enemy.userData.rightLeg = rightLeg;

    // Feet (she has one shoe, throws the others)
    const footGeo = new THREE.BoxGeometry(0.12, 0.08, 0.2);
    const shoeMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.6
    });

    const leftFoot = new THREE.Mesh(footGeo, shoeMat);
    leftFoot.position.set(-0.2, -0.54, 0.05);
    enemy.add(leftFoot);

    const rightFoot = new THREE.Mesh(footGeo, shoeMat);
    rightFoot.position.set(0.2, -0.54, 0.05);
    enemy.add(rightFoot);

    // Position on platform
    const startX = (PLATFORM_WIDTH / 2) - ENEMY_SAFE_MARGIN;
    const startZ = (PLATFORM_DEPTH / 2) - ENEMY_SAFE_MARGIN;
    enemy.position.set(startX, 0, startZ);

    // Scale up the whole character
    enemy.scale.setScalar(ENEMY_SIZE);

    // Animation data
    enemy.userData.baseY = 0;
    enemy.userData.animTime = 0;
    enemy.userData.isAttacking = false;
    enemy.userData.attackTime = 0;
    enemy.userData.attackPhase = 0; // 0=idle, 1=wind-up, 2=throw, 3=follow-through
    enemy.userData.walkTimer = 0;
    enemy.userData.targetX = startX;
    enemy.userData.targetZ = startZ;

    scene.add(enemy);
    gameState.enemy = enemy;
}

function updateEnemy() {
    if (!gameState.enemy || !gameState.playerBox || gameState.isFalling) return;

    const enemy = gameState.enemy;
    const now = performance.now();
    const deltaTime = 0.016;

    enemy.userData.animTime += deltaTime;
    enemy.userData.walkTimer += deltaTime;

    // Choose new target periodically
    if (enemy.userData.walkTimer > 2.5 + Math.random() * 2) {
        enemy.userData.walkTimer = 0;
        pickNewEnemyTarget();
    }

    // Move toward target
    const dx = enemy.userData.targetX - enemy.position.x;
    const dz = enemy.userData.targetZ - enemy.position.z;
    const distToTarget = Math.sqrt(dx * dx + dz * dz);

    if (distToTarget > 0.1 && !enemy.userData.isAttacking) {
        const enemySpeed = typeof getEnemySpeedForTier === 'function' ? getEnemySpeedForTier() : ENEMY_BASE_SPEED;
        const moveX = (dx / distToTarget) * enemySpeed;
        const moveZ = (dz / distToTarget) * enemySpeed;

        enemy.position.x += moveX;
        enemy.position.z += moveZ;

        // Walking animation
        const walkCycle = Math.sin(enemy.userData.animTime * 6);
        if (enemy.userData.leftLeg) {
            enemy.userData.leftLeg.rotation.x = walkCycle * 0.25;
        }
        if (enemy.userData.rightLeg) {
            enemy.userData.rightLeg.rotation.x = -walkCycle * 0.25;
        }
    } else {
        // Idle
        if (enemy.userData.leftLeg) enemy.userData.leftLeg.rotation.x = 0;
        if (enemy.userData.rightLeg) enemy.userData.rightLeg.rotation.x = 0;
    }

    // Keep on platform
    const hw = PLATFORM_WIDTH / 2 - ENEMY_SAFE_MARGIN;
    const hd = PLATFORM_DEPTH / 2 - ENEMY_SAFE_MARGIN;
    enemy.position.x = Math.max(-hw, Math.min(hw, enemy.position.x));
    enemy.position.z = Math.max(-hd, Math.min(hd, enemy.position.z));

    // Face the player
    const playerDx = gameState.playerBox.position.x - enemy.position.x;
    const playerDz = gameState.playerBox.position.z - enemy.position.z;
    const targetAngle = Math.atan2(playerDx, playerDz);

    let angleDiff = targetAngle - enemy.rotation.y;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    enemy.rotation.y += angleDiff * 0.08;

    // Throwing animation with shoe removal
    if (enemy.userData.isAttacking && enemy.userData.rightArm) {
        const elapsed = now - enemy.userData.attackTime;
        const arm = enemy.userData.rightArm;
        const leftLeg = enemy.userData.leftLeg;
        const heldShoe = enemy.userData.heldShoe;

        if (elapsed < 300) {
            // Phase 1: Bend down to grab shoe from foot
            const progress = elapsed / 300;
            // Bend body forward
            enemy.children[0].rotation.x = 0.3 * progress; // torso
            enemy.children[1].rotation.x = 0.2 * progress; // upper body
            // Lift left leg
            if (leftLeg) leftLeg.rotation.x = -0.8 * progress;
            // Reach down with arm
            arm.rotation.x = 1.2 * progress;
            arm.rotation.z = -0.3 + 0.3 * progress;
            // Show held shoe at end
            if (progress > 0.7 && heldShoe) heldShoe.visible = true;
        } else if (elapsed < 500) {
            // Phase 2: Stand up with shoe
            const progress = (elapsed - 300) / 200;
            enemy.children[0].rotation.x = 0.3 * (1 - progress);
            enemy.children[1].rotation.x = 0.2 * (1 - progress);
            if (leftLeg) leftLeg.rotation.x = -0.8 * (1 - progress);
            arm.rotation.x = 1.2 - 2.7 * progress; // Go from reaching down to behind head
            arm.rotation.z = 0 - 0.5 * progress;
        } else if (elapsed < 650) {
            // Phase 3: Throw!
            const progress = (elapsed - 500) / 150;
            arm.rotation.x = -1.5 + 3.0 * progress;
            arm.rotation.z = -0.5 + 0.2 * progress;
            // Hide shoe when thrown (halfway through throw)
            if (progress > 0.3 && heldShoe) heldShoe.visible = false;
        } else if (elapsed < 900) {
            // Phase 4: Follow-through
            const progress = (elapsed - 650) / 250;
            arm.rotation.x = 1.5 - 1.5 * progress;
            arm.rotation.z = -0.3;
        } else {
            // Reset everything
            arm.rotation.x = 0;
            arm.rotation.z = -0.3;
            enemy.children[0].rotation.x = 0;
            enemy.children[1].rotation.x = 0;
            if (leftLeg) leftLeg.rotation.x = 0;
            if (heldShoe) heldShoe.visible = false;
            enemy.userData.isAttacking = false;
        }
    }

    // Slight body movement
    enemy.position.y = enemy.userData.baseY + Math.sin(enemy.userData.animTime * 2) * 0.02;
}

function pickNewEnemyTarget() {
    if (!gameState.enemy || !gameState.playerBox) return;

    const hw = PLATFORM_WIDTH / 2 - ENEMY_SAFE_MARGIN;
    const hd = PLATFORM_DEPTH / 2 - ENEMY_SAFE_MARGIN;
    const playerX = gameState.playerBox.position.x;
    const playerZ = gameState.playerBox.position.z;

    let attempts = 0;
    let targetX, targetZ;
    do {
        targetX = (Math.random() * 2 - 1) * hw;
        targetZ = (Math.random() * 2 - 1) * hd;
        attempts++;
    } while (
        attempts < 20 &&
        Math.sqrt((targetX - playerX) ** 2 + (targetZ - playerZ) ** 2) < ENEMY_MIN_PLAYER_DISTANCE
    );

    gameState.enemy.userData.targetX = targetX;
    gameState.enemy.userData.targetZ = targetZ;
}

function triggerEnemyAttack() {
    if (!gameState.enemy) return;
    gameState.enemy.userData.isAttacking = true;
    gameState.enemy.userData.attackTime = performance.now();
}

function getEnemyGunPosition() {
    if (!gameState.enemy) return { x: 0, y: 0, z: 0 };

    const enemy = gameState.enemy;
    // Hand position when throwing (accounting for scale)
    const handOffset = new THREE.Vector3(0.5 * ENEMY_SIZE, 1.8 * ENEMY_SIZE, 0.3 * ENEMY_SIZE);
    handOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), enemy.rotation.y);

    return {
        x: enemy.position.x + handOffset.x,
        y: enemy.position.y + handOffset.y,
        z: enemy.position.z + handOffset.z
    };
}

function resetEnemy() {
    if (!gameState.enemy) return;

    // Pick a random corner far from the player (who starts at 0,0)
    var corners = [
        { x:  1, z:  1 },
        { x:  1, z: -1 },
        { x: -1, z:  1 },
        { x: -1, z: -1 }
    ];
    var pick = corners[Math.floor(Math.random() * corners.length)];
    var startX = pick.x * ((PLATFORM_WIDTH / 2) - ENEMY_SAFE_MARGIN);
    var startZ = pick.z * ((PLATFORM_DEPTH / 2) - ENEMY_SAFE_MARGIN);

    gameState.enemy.position.set(startX, 0, startZ);
    gameState.enemy.rotation.y = 0;
    gameState.enemy.userData.targetX = startX;
    gameState.enemy.userData.targetZ = startZ;
    gameState.enemy.userData.walkTimer = 0;
    gameState.enemy.userData.animTime = 0;
    gameState.enemy.userData.isAttacking = false;

    if (gameState.enemy.userData.leftLeg) gameState.enemy.userData.leftLeg.rotation.x = 0;
    if (gameState.enemy.userData.rightLeg) gameState.enemy.userData.rightLeg.rotation.x = 0;
    if (gameState.enemy.userData.rightArm) {
        gameState.enemy.userData.rightArm.rotation.x = 0;
        gameState.enemy.userData.rightArm.rotation.z = -0.3;
    }
}


// ========== taunts.js ==========
/**
 * Lablix - Taunt System (Phase 8)
 * With Web Speech API for voice taunts and multilingual support
 */

// Taunt cooldown in ms
const TAUNT_COOLDOWN = 1000;
const TAUNT_DISPLAY_TIME = 5000;

// Speech synthesis
let speechEnabled = true;
let speechVoice = null;
let currentAudio = null;
let tauntSpeaking = false;

function initSpeech() {
    if (!('speechSynthesis' in window)) {
        console.log('Speech synthesis not supported');
        speechEnabled = false;
        return;
    }

    // Get voices when available
    if (speechSynthesis.getVoices().length > 0) {
        updateSpeechVoice();
    }
    speechSynthesis.onvoiceschanged = updateSpeechVoice;
}

function updateSpeechVoice() {
    const voices = speechSynthesis.getVoices();
    if (voices.length === 0) return;

    const lang = typeof getLanguage === 'function' ? getLanguage() : 'en';
    const langConfig = LANGUAGES[lang];
    const preferredVoices = langConfig ? langConfig.voices : [];

    // Language codes to match (some devices use different codes)
    const langCodes = {
        'en': ['en-', 'en_'],
        'it': ['it-', 'it_', 'it']
    };
    const prefixes = langCodes[lang] || [lang];

    // Helper to check if voice matches language
    const matchesLang = (voice) => {
        const vl = voice.lang.toLowerCase();
        return prefixes.some(p => vl.startsWith(p));
    };

    // 1. Try preferred voices that match language
    for (const preferred of preferredVoices) {
        const found = voices.find(v => v.name.includes(preferred) && matchesLang(v));
        if (found) {
            speechVoice = found;
            console.log('Selected preferred voice:', found.name, found.lang);
            return;
        }
    }

    // 2. Any voice matching the language
    const langVoices = voices.filter(matchesLang);
    if (langVoices.length > 0) {
        // Prefer female voices for the enemy character
        speechVoice = langVoices.find(v =>
            v.name.toLowerCase().includes('female') ||
            v.name.toLowerCase().includes('woman') ||
            v.name.toLowerCase().includes('alice') ||
            v.name.toLowerCase().includes('samantha')
        ) || langVoices[0];
        console.log('Selected language voice:', speechVoice.name, speechVoice.lang);
        return;
    }

    // 3. Ultimate fallback: English or first available
    speechVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
    console.log('Fallback voice:', speechVoice?.name || 'default');
}

function speakTaunt(text) {
    if (!text) return;

    const lang = typeof getLanguage === 'function' ? getLanguage() : 'en';

    // Italian: play pre-generated MP3 if available
    if (lang === 'it' && typeof TAUNTS_AUDIO !== 'undefined' && TAUNTS_AUDIO[text]) {
        stopSpeech();
        tauntSpeaking = true;
        currentAudio = new Audio(TAUNTS_AUDIO[text]);
        currentAudio.volume = 0.85;
        currentAudio.onended = () => { tauntSpeaking = false; };
        currentAudio.onerror = () => { tauntSpeaking = false; };
        currentAudio.play().catch(() => { tauntSpeaking = false; });
        return;
    }

    // English / fallback: use Web Speech API
    if (!speechEnabled) return;
    if (!('speechSynthesis' in window)) return;

    speechSynthesis.cancel();
    tauntSpeaking = true;

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.1;
    utterance.pitch = 1.2;
    utterance.volume = 0.8;
    utterance.onend = () => { tauntSpeaking = false; };
    utterance.onerror = () => { tauntSpeaking = false; };

    const langMap = { en: 'en-US', it: 'it-IT' };
    utterance.lang = langMap[lang] || 'en-US';

    if (speechVoice) {
        utterance.voice = speechVoice;
    }

    speechSynthesis.speak(utterance);
}

function stopSpeech() {
    tauntSpeaking = false;
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
    }
    if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
    }
}

// Per-category taunt tracking via localStorage â€” no repeats until all used
function getPlayedTaunts(category) {
    try {
        var data = JSON.parse(localStorage.getItem('lablix_taunts_played') || '{}');
        return data[category] || [];
    } catch(e) { return []; }
}

function markTauntPlayed(category, index) {
    try {
        var data = JSON.parse(localStorage.getItem('lablix_taunts_played') || '{}');
        if (!data[category]) data[category] = [];
        data[category].push(index);
        localStorage.setItem('lablix_taunts_played', JSON.stringify(data));
    } catch(e) {}
}

function resetCategoryPlayed(category) {
    try {
        var data = JSON.parse(localStorage.getItem('lablix_taunts_played') || '{}');
        delete data[category];
        localStorage.setItem('lablix_taunts_played', JSON.stringify(data));
    } catch(e) {}
}

function getRandomTaunt(category) {
    if (typeof TAUNTS_DATA === 'undefined') return null;
    var lang = typeof getLanguage === 'function' ? getLanguage() : 'en';
    var cat = TAUNTS_DATA[category];
    if (!cat) return null;
    var taunts = cat[lang] || cat['en'];
    if (!taunts || taunts.length === 0) return null;

    var played = getPlayedTaunts(category);

    // Build list of unplayed indices
    var available = [];
    for (var i = 0; i < taunts.length; i++) {
        if (played.indexOf(i) === -1) available.push(i);
    }

    // All played â€” reset and use full list
    if (available.length === 0) {
        resetCategoryPlayed(category);
        available = [];
        for (var j = 0; j < taunts.length; j++) available.push(j);
    }

    var pick = available[Math.floor(Math.random() * available.length)];
    markTauntPlayed(category, pick);
    return taunts[pick];
}

function showTaunt(text, force) {
    if (!text) return;

    const now = performance.now();

    // Normal taunts must wait for current speech to finish
    if (!force && tauntSpeaking) return;

    // Check cooldown (force bypasses)
    if (!force && now - gameState.lastTauntTime < TAUNT_COOLDOWN) return;
    gameState.lastTauntTime = now;

    // Remove existing taunt
    hideTaunt();

    // Create speech bubble
    const bubble = document.createElement('div');
    bubble.id = 'enemy-taunt';
    bubble.className = 'speech-bubble';
    bubble.textContent = text;

    document.getElementById('game-container').appendChild(bubble);
    gameState.currentTaunt = bubble;

    // Speak the taunt
    speakTaunt(text);

    // Animate in
    requestAnimationFrame(() => {
        bubble.classList.add('visible');
    });

    // Auto-hide after display time
    setTimeout(() => {
        hideTaunt();
    }, TAUNT_DISPLAY_TIME);
}

function hideTaunt() {
    const existing = document.getElementById('enemy-taunt');
    if (existing) {
        existing.classList.remove('visible');
        setTimeout(() => existing.remove(), 300);
    }
    gameState.currentTaunt = null;
}

function triggerTaunt(category) {
    const taunt = getRandomTaunt(category);
    showTaunt(taunt);
}

// Check for taunt triggers based on game state
function checkTauntTriggers() {
    if (!gameState.isPlaying || gameState.isFalling) return;
    if (!gameState.playerBox) return;

    const now = performance.now();
    if (now - gameState.lastTauntTime < TAUNT_COOLDOWN) return;

    const px = gameState.playerBox.position.x;
    const pz = gameState.playerBox.position.z;
    const hw = PLATFORM_WIDTH / 2;
    const hd = PLATFORM_DEPTH / 2;

    // Edge margin (15% of platform size)
    const edgeMargin = Math.min(hw, hd) * 0.15;

    // Check edge proximity
    const nearEdge = (
        px < -hw + edgeMargin ||
        px > hw - edgeMargin ||
        pz < -hd + edgeMargin ||
        pz > hd - edgeMargin
    );

    if (nearEdge) {
        triggerTaunt('edge_proximity');
        return;
    }

    // Check reckless movement (high velocity)
    const speed = Math.sqrt(
        gameState.velocity.x ** 2 +
        gameState.velocity.z ** 2
    );

    if (speed > MAX_VELOCITY * 0.8) {
        if (Math.random() < 0.05) {
            triggerTaunt('reckless_movement');
            return;
        }
    }

    // Check near death
    if (gameState.lives === 1 && Math.random() < 0.015) {
        triggerTaunt('near_death');
        return;
    }

    // Random general mockery
    const tauntChance = typeof getTauntChanceForTier === 'function' ? getTauntChanceForTier() : 0.001;
    if (Math.random() < tauntChance) {
        triggerTaunt('general_mockery');
    }
}

function triggerFallTaunt() {
    // Force interrupt â€” fall is critical
    const taunt = getRandomTaunt('fall_off_edge');
    showTaunt(taunt, true);
}

function triggerHitTaunt() {
    // Don't interrupt ongoing taunt â€” only fall/death can interrupt
    const taunt = getRandomTaunt('after_hit');
    showTaunt(taunt);
}

function triggerDeathTaunt() {
    // Force interrupt â€” death is critical
    const taunt = getRandomTaunt('final_death');
    showTaunt(taunt, true);
}


// ========== projectile.js ==========
/**
 * Lablix - Projectile System (Phase 9)
 * Shoes that bounce and slide until they fall off the platform
 */

const SHOE_LENGTH = 0.5;
const SHOE_WIDTH = 0.2;
const SHOE_HEIGHT = 0.15;
const HEEL_HEIGHT = 0.25;
const PROJECTILE_RADIUS = 0.3; // For collision detection
const PROJECTILE_GRAVITY = 0.005;
const PROJECTILE_BOUNCE = 0.4;
const PROJECTILE_FRICTION = 0.992; // Higher = slides much longer
const MIN_SLIDE_SPEED = 0.008; // Minimum speed to keep sliding

function createProjectile() {
    if (!gameState.enemy || !gameState.playerBox) return;

    const gunPos = getEnemyGunPosition();
    const accuracy = getAccuracyForTier();
    const projectileSpeed = getProjectileSpeedForTier();

    // Create high heel shoe geometry
    const shoeGroup = new THREE.Group();

    // Shoe colors - red high heel
    const shoeMat = new THREE.MeshStandardMaterial({
        color: 0xcc0033, // Red patent leather
        roughness: 0.3,
        metalness: 0.2
    });
    const soleMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.9
    });

    // Main shoe body (front part, angled up toward heel)
    const bodyGeo = new THREE.BoxGeometry(SHOE_WIDTH, SHOE_HEIGHT, SHOE_LENGTH * 0.7);
    const body = new THREE.Mesh(bodyGeo, shoeMat);
    body.position.set(0, SHOE_HEIGHT / 2, SHOE_LENGTH * 0.15);
    body.rotation.x = 0.15; // Slight upward angle
    shoeGroup.add(body);

    // Pointed toe
    const toeGeo = new THREE.ConeGeometry(SHOE_WIDTH * 0.5, SHOE_LENGTH * 0.3, 4);
    const toe = new THREE.Mesh(toeGeo, shoeMat);
    toe.rotation.x = Math.PI / 2;
    toe.rotation.y = Math.PI / 4;
    toe.position.set(0, SHOE_HEIGHT * 0.4, SHOE_LENGTH * 0.55);
    shoeGroup.add(toe);

    // Heel back (connects to stiletto)
    const heelBackGeo = new THREE.BoxGeometry(SHOE_WIDTH * 0.9, SHOE_HEIGHT * 1.2, SHOE_LENGTH * 0.2);
    const heelBack = new THREE.Mesh(heelBackGeo, shoeMat);
    heelBack.position.set(0, SHOE_HEIGHT * 0.6 + HEEL_HEIGHT * 0.3, -SHOE_LENGTH * 0.35);
    shoeGroup.add(heelBack);

    // Stiletto heel (high heel)
    const stilettoGeo = new THREE.CylinderGeometry(0.03, 0.05, HEEL_HEIGHT, 8);
    const stiletto = new THREE.Mesh(stilettoGeo, soleMat);
    stiletto.position.set(0, HEEL_HEIGHT / 2, -SHOE_LENGTH * 0.35);
    shoeGroup.add(stiletto);

    // Heel tip (bottom of stiletto)
    const heelTipGeo = new THREE.CylinderGeometry(0.04, 0.03, 0.03, 8);
    const heelTip = new THREE.Mesh(heelTipGeo, soleMat);
    heelTip.position.set(0, 0.015, -SHOE_LENGTH * 0.35);
    shoeGroup.add(heelTip);

    // Sole (angled from toe to heel)
    const soleGeo = new THREE.BoxGeometry(SHOE_WIDTH * 0.95, 0.03, SHOE_LENGTH * 0.75);
    const sole = new THREE.Mesh(soleGeo, soleMat);
    sole.position.set(0, 0.05, SHOE_LENGTH * 0.1);
    sole.rotation.x = 0.2;
    shoeGroup.add(sole);

    // Inner sole (red bottom like Louboutin)
    const innerSoleMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.4
    });
    const innerSole = new THREE.Mesh(soleGeo.clone(), innerSoleMat);
    innerSole.position.set(0, 0.02, SHOE_LENGTH * 0.1);
    innerSole.rotation.x = 0.2;
    shoeGroup.add(innerSole);

    shoeGroup.position.set(gunPos.x, gunPos.y, gunPos.z);
    shoeGroup.castShadow = true;

    // Calculate direction to player with accuracy variance
    const targetX = gameState.playerBox.position.x;
    const targetZ = gameState.playerBox.position.z;
    const targetY = BOX_SIZE / 2;

    const inaccuracyRange = (1 - accuracy) * 3;
    const offsetX = (Math.random() - 0.5) * inaccuracyRange;
    const offsetZ = (Math.random() - 0.5) * inaccuracyRange;

    let predictedX = targetX + offsetX;
    let predictedZ = targetZ + offsetZ;

    // Tier 4: predictive aiming
    if (gameState.difficultyTier >= 4) {
        const predictionTime = 1.0;
        predictedX = targetX + gameState.velocity.x * predictionTime * 60 + offsetX * 0.3;
        predictedZ = targetZ + gameState.velocity.z * predictionTime * 60 + offsetZ * 0.3;
    }

    const dx = predictedX - gunPos.x;
    const dy = targetY - gunPos.y;
    const dz = predictedZ - gunPos.z;
    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

    // Set velocity with arc
    shoeGroup.userData.velocity = {
        x: (dx / distance) * projectileSpeed,
        y: (dy / distance) * projectileSpeed + 0.08, // Higher arc for thrown shoe
        z: (dz / distance) * projectileSpeed
    };

    // Rotation velocity (tumbling shoe)
    shoeGroup.userData.rotVelocity = {
        x: (Math.random() - 0.5) * 0.3,
        y: (Math.random() - 0.5) * 0.2,
        z: (Math.random() - 0.5) * 0.3
    };

    shoeGroup.userData.spawnTime = performance.now();
    shoeGroup.userData.onPlatform = false;
    shoeGroup.userData.bounceCount = 0;

    scene.add(shoeGroup);
    gameState.projectiles.push(shoeGroup);

    // Trigger attack animation
    triggerEnemyAttack();
}

function updateProjectiles() {
    if (!gameState.isPlaying) return;

    const toRemove = [];
    const hw = PLATFORM_WIDTH / 2;
    const hd = PLATFORM_DEPTH / 2;
    const platformSurface = SHOE_HEIGHT / 2;

    gameState.projectiles.forEach((shoe, index) => {
        if (!shoe) return;

        const vel = shoe.userData.velocity;
        const rotVel = shoe.userData.rotVelocity;

        // Apply gravity
        vel.y -= PROJECTILE_GRAVITY;

        // Apply friction when on platform
        if (shoe.userData.onPlatform) {
            vel.x *= PROJECTILE_FRICTION;
            vel.z *= PROJECTILE_FRICTION;
            // Slow down rotation when on ground
            rotVel.x *= 0.95;
            rotVel.y *= 0.98;
            rotVel.z *= 0.95;
        }

        // Update position
        shoe.position.x += vel.x;
        shoe.position.y += vel.y;
        shoe.position.z += vel.z;

        // Update rotation (tumbling)
        shoe.rotation.x += rotVel.x;
        shoe.rotation.y += rotVel.y;
        shoe.rotation.z += rotVel.z;

        const px = shoe.position.x;
        const pz = shoe.position.z;
        const py = shoe.position.y;

        // Is over platform?
        const overPlatform = px > -hw && px < hw && pz > -hd && pz < hd;

        if (overPlatform) {
            // Bounce on platform surface
            if (py <= platformSurface && vel.y < 0) {
                shoe.position.y = platformSurface;
                vel.y = -vel.y * PROJECTILE_BOUNCE;
                shoe.userData.bounceCount++;
                shoe.userData.onPlatform = true;

                // Add some horizontal scatter on bounce
                vel.x += (Math.random() - 0.5) * 0.015;
                vel.z += (Math.random() - 0.5) * 0.015;

                // Increase rotation on bounce
                rotVel.x += (Math.random() - 0.5) * 0.08;
                rotVel.z += (Math.random() - 0.5) * 0.08;

                // Create bounce effect
                if (shoe.userData.bounceCount <= 3) {
                    createBounceEffect(px, pz);
                }

                // If barely bouncing, stay on ground
                if (Math.abs(vel.y) < 0.012) {
                    vel.y = 0;
                    shoe.position.y = platformSurface;
                }
            }

            // CRITICAL: If shoe is moving too slowly on platform, push it toward nearest edge
            const horizontalSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
            if (shoe.userData.onPlatform && horizontalSpeed < MIN_SLIDE_SPEED) {
                // Find nearest edge and push toward it
                const distToLeft = px + hw;
                const distToRight = hw - px;
                const distToFront = pz + hd;
                const distToBack = hd - pz;

                const minDist = Math.min(distToLeft, distToRight, distToFront, distToBack);
                const pushForce = 0.012;

                if (minDist === distToLeft) {
                    vel.x = -pushForce;
                } else if (minDist === distToRight) {
                    vel.x = pushForce;
                } else if (minDist === distToFront) {
                    vel.z = -pushForce;
                } else {
                    vel.z = pushForce;
                }

                // Add slight random wobble
                vel.x += (Math.random() - 0.5) * 0.003;
                vel.z += (Math.random() - 0.5) * 0.003;
            }
        } else {
            // Off platform - fall into void
            shoe.userData.onPlatform = false;

            // Only remove when fallen far enough
            if (py < -20) {
                toRemove.push(index);
                return;
            }
        }

        // NEVER remove shoes while on or near platform - they MUST fall off
        // Only remove if fallen deep into void
        if (py < -20) {
            toRemove.push(index);
        }
    });

    // Remove fallen shoes
    toRemove.sort((a, b) => b - a).forEach(index => {
        removeProjectile(index);
    });
}

function createBounceEffect(x, z) {
    // Small dust particles on bounce
    for (let i = 0; i < 3; i++) {
        const geo = new THREE.SphereGeometry(0.04, 6, 6);
        const mat = new THREE.MeshBasicMaterial({
            color: 0x8B7355,
            transparent: true,
            opacity: 0.8
        });
        const dust = new THREE.Mesh(geo, mat);
        dust.position.set(x, 0.1, z);

        const angle = (i / 3) * Math.PI * 2 + Math.random();
        dust.userData.velocity = {
            x: Math.cos(angle) * 0.05,
            y: 0.04,
            z: Math.sin(angle) * 0.05
        };
        dust.userData.life = 1;
        scene.add(dust);

        function animateDust() {
            dust.userData.life -= 0.06;
            dust.userData.velocity.y -= 0.003;
            dust.position.x += dust.userData.velocity.x;
            dust.position.y += dust.userData.velocity.y;
            dust.position.z += dust.userData.velocity.z;
            dust.material.opacity = dust.userData.life * 0.8;
            dust.scale.setScalar(0.5 + dust.userData.life * 0.5);

            if (dust.userData.life > 0) {
                requestAnimationFrame(animateDust);
            } else {
                scene.remove(dust);
            }
        }
        animateDust();
    }
}

function removeProjectile(index) {
    const shoe = gameState.projectiles[index];
    if (shoe) {
        scene.remove(shoe);
        gameState.projectiles.splice(index, 1);
    }
}

function clearAllProjectiles() {
    gameState.projectiles.forEach(shoe => {
        if (shoe) scene.remove(shoe);
    });
    gameState.projectiles = [];
}

function checkEnemyShooting() {
    if (!gameState.isPlaying || gameState.isFalling) return;
    if (!gameState.enemy) return;

    // Check if shooting is allowed (not during tier-up cooldown)
    if (typeof canEnemyShoot === 'function' && !canEnemyShoot()) return;

    const now = performance.now();
    const fireRate = getFireRateForTier();

    if (now - gameState.lastShotTime >= fireRate) {
        gameState.lastShotTime = now;
        createProjectile();
        playWosh();
    }
}


// ========== collision.js ==========
/**
 * Lablix - Hit Detection & Collision System (Phase 10)
 * Includes enemy collision (solid wall) and multilingual support
 */

const HIT_COOLDOWN = 1000; // Invulnerability time after hit (ms)
const KNOCKBACK_FORCE = 0.12;
const ENEMY_COLLISION_RADIUS = 1.0; // Collision radius for enemy character

function checkProjectileCollisions() {
    if (!gameState.isPlaying || gameState.isFalling) return;
    if (!gameState.playerBox) return;

    const now = performance.now();

    // Check if still in hit cooldown
    if (now - gameState.lastHitTime < HIT_COOLDOWN) {
        // Flash player box during invulnerability
        const flash = Math.sin(now * 0.03) > 0;
        if (gameState.playerBox.material) {
            gameState.playerBox.material.opacity = flash ? 0.4 : 1;
            gameState.playerBox.material.transparent = true;
        }
        return;
    } else if (gameState.playerBox.material) {
        gameState.playerBox.material.opacity = 1;
        gameState.playerBox.material.transparent = false;
    }

    const playerPos = gameState.playerBox.position;
    // Use box collision (AABB) instead of sphere for more accurate detection
    const boxHalfSize = BOX_SIZE / 2;

    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const projectile = gameState.projectiles[i];
        if (!projectile) continue;

        const projPos = projectile.position;
        const projRadius = PROJECTILE_RADIUS;

        // AABB vs Sphere collision
        // Find closest point on box to sphere center
        const closestX = Math.max(playerPos.x - boxHalfSize, Math.min(projPos.x, playerPos.x + boxHalfSize));
        const closestY = Math.max(playerPos.y - boxHalfSize, Math.min(projPos.y, playerPos.y + boxHalfSize));
        const closestZ = Math.max(playerPos.z - boxHalfSize, Math.min(projPos.z, playerPos.z + boxHalfSize));

        // Distance from closest point to sphere center
        const dx = projPos.x - closestX;
        const dy = projPos.y - closestY;
        const dz = projPos.z - closestZ;
        const distSq = dx * dx + dy * dy + dz * dz;

        if (distSq < projRadius * projRadius) {
            // HIT!
            onPlayerHit(projectile, i);
            return; // Only one hit per frame
        }
    }
}

// Check collision between player box and enemy character
function checkEnemyCollision() {
    if (!gameState.isPlaying || gameState.isFalling) return;
    if (!gameState.playerBox || !gameState.enemy) return;

    const playerPos = gameState.playerBox.position;
    const enemyPos = gameState.enemy.position;
    const boxHalfSize = BOX_SIZE / 2;

    // Calculate distance between player and enemy (XZ plane only)
    const dx = playerPos.x - enemyPos.x;
    const dz = playerPos.z - enemyPos.z;
    const distXZ = Math.sqrt(dx * dx + dz * dz);

    // Combined collision radius (enemy radius + box half diagonal on XZ)
    const boxRadius = boxHalfSize * Math.sqrt(2);
    const minDist = ENEMY_COLLISION_RADIUS + boxRadius;

    if (distXZ < minDist) {
        // Collision! Push player back
        const overlap = minDist - distXZ;

        // Normalize direction
        const len = Math.sqrt(dx * dx + dz * dz);
        if (len > 0) {
            const nx = dx / len;
            const nz = dz / len;

            // Push player out of enemy
            gameState.playerBox.position.x += nx * overlap;
            gameState.playerBox.position.z += nz * overlap;

            // Bounce velocity (reverse and dampen)
            const dotProduct = gameState.velocity.x * nx + gameState.velocity.z * nz;
            if (dotProduct < 0) {
                // Only bounce if moving toward enemy
                gameState.velocity.x -= 2 * dotProduct * nx * 0.5;
                gameState.velocity.z -= 2 * dotProduct * nz * 0.5;

                // Dampen velocity
                gameState.velocity.x *= 0.5;
                gameState.velocity.z *= 0.5;
            }
        }
    }
}

function onPlayerHit(projectile, projectileIndex) {
    playHit();
    const now = performance.now();
    gameState.lastHitTime = now;
    gameState.isHit = true;

    // Reduce lives
    gameState.lives--;
    updateUI();

    // Calculate knockback direction (from projectile to player)
    const knockbackX = projectile.userData.velocity.x * KNOCKBACK_FORCE * 10;
    const knockbackZ = projectile.userData.velocity.z * KNOCKBACK_FORCE * 10;

    // Apply knockback
    gameState.velocity.x += knockbackX;
    gameState.velocity.z += knockbackZ;

    // Remove the projectile
    removeProjectile(projectileIndex);

    // Visual feedback
    createHitEffect(gameState.playerBox.position);
    triggerScreenShake();
    flashPlayerRed();

    // Trigger taunt
    triggerHitTaunt();

    // Check for game over
    if (gameState.lives <= 0) {
        onShotDeath();
    }

    // Reset hit state after cooldown
    setTimeout(() => {
        gameState.isHit = false;
    }, HIT_COOLDOWN);
}

function createHitEffect(position) {
    // Create impact particles
    const particleCount = 8;
    const particles = [];

    for (let i = 0; i < particleCount; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({
            color: 0xff3300,
            transparent: true,
            opacity: 1
        });
        const particle = new THREE.Mesh(geometry, material);

        const angle = (i / particleCount) * Math.PI * 2;
        particle.position.set(
            position.x,
            position.y,
            position.z
        );
        particle.userData.velocity = {
            x: Math.cos(angle) * 0.15,
            y: 0.1 + Math.random() * 0.1,
            z: Math.sin(angle) * 0.15
        };
        particle.userData.life = 1;

        scene.add(particle);
        particles.push(particle);
    }

    // Animate particles
    function animateParticles() {
        let alive = false;
        particles.forEach(p => {
            if (p.userData.life > 0) {
                alive = true;
                p.userData.life -= 0.04;
                p.userData.velocity.y -= 0.01; // Gravity
                p.position.x += p.userData.velocity.x;
                p.position.y += p.userData.velocity.y;
                p.position.z += p.userData.velocity.z;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
            }
        });

        if (alive) {
            requestAnimationFrame(animateParticles);
        } else {
            particles.forEach(p => scene.remove(p));
        }
    }
    animateParticles();
}

function triggerScreenShake() {
    const container = document.getElementById('game-container');
    if (!container) return;

    container.classList.add('screen-shake');
    setTimeout(() => {
        container.classList.remove('screen-shake');
    }, 300);
}

function flashPlayerRed() {
    if (!gameState.playerBox) return;

    // Store original color
    const originalColor = gameState.playerBox.material.color.getHex();

    // Flash red
    gameState.playerBox.material.color.setHex(0xff0000);
    gameState.playerBox.material.emissive = new THREE.Color(0xff0000);
    gameState.playerBox.material.emissiveIntensity = 0.5;

    // Restore after brief delay
    setTimeout(() => {
        if (gameState.playerBox && gameState.playerBox.material) {
            gameState.playerBox.material.color.setHex(originalColor);
            gameState.playerBox.material.emissive = new THREE.Color(0x000000);
            gameState.playerBox.material.emissiveIntensity = 0;
        }
    }, 150);
}

function onShotDeath() {
    stopAllFx();
    gameState.isPlaying = false;

    // Trigger death taunt
    triggerDeathTaunt();

    // Clear projectiles
    clearAllProjectiles();

    // Show game over after brief delay with translated message
    setTimeout(() => {
        const msg = typeof getDeathMessage === 'function' ? getDeathMessage('hit') : 'You Were Hit!';
        showGameOver(msg);
    }, 1500);
}

function resetCombatState() {
    gameState.projectiles = [];
    gameState.lastShotTime = performance.now() + 1500; // Grace period before first shot
    gameState.lastHitTime = 0;
    gameState.isHit = false;
    gameState.hitCooldown = 0;
    gameState.difficultyTier = 1;

    // Reset taunt state
    gameState.lastTauntTime = 0;
    hideTaunt();
}


// ========== ui.js ==========
/**
 * Lablix - UI System
 * With multilingual support
 */

function showScreen(name) {
    gameState.currentScreen = name;
    startScreen.classList.add('hidden');
    calibrationScreen.classList.add('hidden');
    gameContainer.classList.add('hidden');
    document.getElementById('desktop-message').classList.add('hidden');

    if (name === 'start') startScreen.classList.remove('hidden');
    else if (name === 'calibration') calibrationScreen.classList.remove('hidden');
    else if (name === 'game') gameContainer.classList.remove('hidden');
}

function updateUI() {
    document.getElementById('score').textContent = gameState.score;
    document.querySelectorAll('.heart').forEach((h, i) => {
        h.classList.toggle('lost', i >= gameState.lives);
    });
}

function showGameOver(msg) {
    gameState.isPlaying = false;
    releaseWakeLock();

    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('lablix_highscore', gameState.highScore);
    }

    // Get translated text
    const gameOverTitle = typeof getText === 'function' ? getText('ui', 'gameOver') : 'GAME OVER';
    const scoreLabel = typeof getText === 'function' ? getText('ui', 'score') : 'SCORE';
    const highScoreLabel = typeof getText === 'function' ? getText('ui', 'highScore') : 'High Score';
    const playAgainLabel = typeof getText === 'function' ? getText('ui', 'playAgain') : 'PLAY AGAIN';

    const exitLabel = typeof getText === 'function' ? getText('ui', 'exit') : 'EXIT';

    const overlay = document.createElement('div');
    overlay.id = 'game-over-overlay';
    overlay.innerHTML = `
        <div class="game-over-content">
            <h1 class="game-over-title">${gameOverTitle}</h1>
            <div class="game-over-cause">${msg}</div>
            <div class="game-over-score">${scoreLabel}: ${gameState.score}</div>
            <div class="game-over-highscore">${highScoreLabel}: ${gameState.highScore}</div>
            <button id="restart-button" class="game-button">${playAgainLabel}</button>
            <button id="quit-button" class="game-button secondary">${exitLabel}</button>
        </div>
    `;
    document.body.appendChild(overlay);

    document.getElementById('restart-button').onclick = () => {
        overlay.remove();
        // Start music + fullscreen in same gesture context (before any await)
        if (typeof _startBgm === 'function') _startBgm();
        enterFullscreen();
        lockOrientation();
        restartGame();
    };

    document.getElementById('quit-button').onclick = () => {
        overlay.remove();
        onExitClick();
    };
}

// Get translated death message
function getDeathMessage(type) {
    if (typeof getText === 'function') {
        if (type === 'fall') {
            return getText('ui', 'youFell');
        } else if (type === 'hit') {
            return getText('ui', 'youWereHit');
        }
    }
    // Fallback
    return type === 'fall' ? 'You Fell Off!' : 'You Were Hit!';
}


// ========== game.js ==========
/**
 * Lablix - Main Game Controller
 * With multilingual support
 */

function init() {
    if (gameState.initialized) return;
    gameState.initialized = true;

    // Initialize language system first
    if (typeof initLanguage === 'function') {
        initLanguage();
    }

    startScreen = document.getElementById('start-screen');
    calibrationScreen = document.getElementById('calibration-screen');
    gameContainer = document.getElementById('game-container');

    gameState.highScore = parseInt(localStorage.getItem('lablix_highscore') || '0');
    document.getElementById('high-score').textContent = gameState.highScore;

    gameState.isMobile = isMobileDevice();

    // Initialize language selector on start screen
    if (typeof initLanguageSelector === 'function') {
        initLanguageSelector();
    }

    // Update all text with current language
    if (typeof updateAllText === 'function') {
        updateAllText();
    }

    if (!gameState.isMobile) {
        document.getElementById('desktop-message').classList.remove('hidden');
        return;
    }

    showScreen('start');

    document.getElementById('start-button').addEventListener('click', onStartClick);
    document.getElementById('calibrate-button').addEventListener('click', onCalibrateClick);
    document.getElementById('calibration-exit-button').addEventListener('click', onCalibrationExitClick);
    document.getElementById('exit-button').addEventListener('click', onExitClick);
}

async function onStartClick() {
    // Start background music on first play (user gesture context)
    if (typeof _startBgm === 'function') _startBgm();

    const hasPermission = await requestGyroPermission();
    if (!hasPermission) {
        const msg = typeof getText === 'function' ? getText('ui', 'gyroPermission') : 'Gyroscope permission is required to play.';
        alert(msg);
        return;
    }

    startGyroscope();
    await new Promise(r => setTimeout(r, 100));
    await enterFullscreen();
    lockOrientation();
    showScreen('calibration');
}

function onCalibrationExitClick() {
    exitFullscreen();
    unlockOrientation();
    window.removeEventListener('deviceorientation', onDeviceOrientation);
    if (typeof _bgm !== 'undefined') _bgm.pause();

    // Reset calibration UI state
    document.getElementById('calibrate-button').classList.remove('calibrate-visible');
    document.getElementById('calibrate-button').classList.add('calibrate-hidden');
    var guide = document.getElementById('calibration-guide');
    if (guide) guide.classList.remove('hidden');
    document.getElementById('calibration-status').classList.add('hidden');
    var screen = document.getElementById('calibration-screen');
    if (screen) screen.classList.remove('level-ok');

    showScreen('start');
}

function onCalibrateClick() {
    // Re-enter fullscreen + lock (user may have exited during calibration)
    enterFullscreen();
    lockOrientation();

    // Resume music if it was paused
    if (typeof _startBgm === 'function') _startBgm();

    document.getElementById('calibrate-button').classList.add('hidden');
    document.getElementById('calibrate-button').classList.remove('calibrate-visible');
    document.getElementById('calibration-guide').classList.add('hidden');
    document.getElementById('calibration-status').classList.remove('hidden');

    // Init FX audio here (direct user gesture context, before setTimeout)
    initFxAudio();

    setTimeout(() => {
        gameState.calibration.beta = gameState.gyro.beta;
        gameState.calibration.gamma = gameState.gyro.gamma;
        startGame();
    }, 1000);
}

function onExitClick() {
    gameState.isPlaying = false;
    releaseWakeLock();
    exitFullscreen();
    unlockOrientation();

    // Stop music and speech
    if (typeof _bgm !== 'undefined') _bgm.pause();
    if (typeof stopSpeech === 'function') stopSpeech();

    window.removeEventListener('deviceorientation', onDeviceOrientation);
    document.getElementById('calibrate-button').classList.remove('hidden');
    document.getElementById('calibrate-button').classList.add('calibrate-hidden');
    document.getElementById('calibrate-button').classList.remove('calibrate-visible');
    var guide = document.getElementById('calibration-guide');
    if (guide) guide.classList.remove('hidden');
    document.getElementById('calibration-status').classList.add('hidden');

    showScreen('start');

    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('lablix_highscore', gameState.highScore);
        document.getElementById('high-score').textContent = gameState.highScore;
    }
}

let visibilityListenerAdded = false;

function startGame() {
    if (typeof THREE === 'undefined') {
        alert('Error: Three.js failed to load.');
        return;
    }

    tempQuaternion = new THREE.Quaternion();
    rotationAxis = new THREE.Vector3();

    initThreeJS();
    showScreen('game');
    resetGameState();

    // Reset camera (fixes skewed view after exit during fall)
    camera.position.set(0, 18, 14);
    camera.up.set(0, 1, 0);
    camera.lookAt(0, 0, 0);
    camera.updateProjectionMatrix();

    createCoin();    // Spawn first coin

    // Create enemy if first time, always reset position
    if (!gameState.enemy) {
        createEnemy();
    }
    resetEnemy();

    // Initialize difficulty UI
    initDifficultyUI();

    // Initialize speech synthesis
    if (typeof initSpeech === 'function') {
        initSpeech();
    }

    requestWakeLock();

    // Only add global listeners once
    if (!visibilityListenerAdded) {
        visibilityListenerAdded = true;
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && gameState.isPlaying) {
                requestWakeLock();
            }
        });

        // Re-enter fullscreen on tap if user exited it during gameplay/calibration
        document.addEventListener('click', () => {
            if (gameState.currentScreen === 'game' || gameState.currentScreen === 'calibration') {
                if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                    enterFullscreen();
                    lockOrientation();
                }
            }
        });
    }

    gameState.isPlaying = true;
    startStepLoop();

    // Grace period: no shooting for 1.5s so player can orient
    gameState.lastShotTime = performance.now() + 500;

    // Enemy taunts immediately at game start
    const startTaunt = getRandomTaunt('general_mockery');
    showTaunt(startTaunt, true);

    animate();
}

function resetGameState() {
    gameState.score = 0;
    gameState.lives = 5;
    gameState.velocity = { x: 0, z: 0 };
    gameState.isOnPlatform = true;
    gameState.isFalling = false;
    gameState.fallVelocity = 0;
    updateUI();

    if (gameState.playerBox) {
        gameState.playerBox.position.set(0, PLATFORM_ELEVATION + BOX_SIZE / 2 + 0.01, 0);
        gameState.playerBox.quaternion.set(0, 0, 0, 1);
    }
}

function restartGame() {
    // Resume background music
    if (typeof _startBgm === 'function') _startBgm();

    // Reset game state
    gameState.isFalling = false;
    gameState.fallVelocity = 0;
    gameState.fallRotation = { x: 0, z: 0 };
    resetGameState();

    // Reset combat state
    resetCombatState();
    clearAllProjectiles();

    // Reset enemy position
    resetEnemy();

    // Reset difficulty
    resetDifficulty();

    // Respawn coin
    createCoin();

    // Re-request wake lock
    requestWakeLock();

    // Fully reset camera (after all state resets, right before animate)
    camera.position.set(0, 18, 14);
    camera.up.set(0, 1, 0);
    camera.lookAt(0, 0, 0);
    camera.updateProjectionMatrix();

    gameState.isPlaying = true;
    startStepLoop();

    // Grace period: no shooting for 1.5s so player can orient
    gameState.lastShotTime = performance.now() + 1500;

    // Enemy taunts immediately on restart
    const startTaunt = getRandomTaunt('general_mockery');
    showTaunt(startTaunt, true);

    animate();
}

function animate() {
    if (!gameState.isPlaying) return;
    requestAnimationFrame(animate);

    // Check if paused for tier-up notification
    const pausedForTierUp = typeof isGamePausedForTierUp === 'function' && isGamePausedForTierUp();

    if (gameState.isFalling) {
        updateFalling();
    } else if (!pausedForTierUp) {
        // Only update gameplay when not paused for tier-up
        updatePhysics();
        updateStepSound();
        checkEnemyCollision(); // Check collision with enemy (solid wall)
        updateCoin();
        updateEnemy();
        checkEnemyShooting();
        updateProjectiles();
        checkProjectileCollisions();
        checkTauntTriggers();
        updateDifficultyUI();
    } else {
        // Still update difficulty UI to track when pause ends
        updateDifficultyUI();
    }

    // Animate background (shooting stars, aliens, etc.)
    updateBackground();

    // Edge pulse animation (always runs for visual continuity)
    const pulse = 0.7 + Math.sin(performance.now() * 0.003) * 0.3;
    platformEdges.forEach(e => e.material.opacity = pulse);

    renderer.render(scene, camera);
}

// Initialize when DOM ready
document.addEventListener('DOMContentLoaded', init);
if (document.readyState !== 'loading') init();

